<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hackintosh</title>
    <url>/2020/12/11/Hackintosh/</url>
    <content><![CDATA[<p>macintosh 麦金塔</p>
<h1 id="Issue"><a href="#Issue" class="headerlink" title="Issue"></a>Issue</h1><ul>
<li><p>黑苹果 屏幕亮度</p>
</li>
<li><p>win下关机变重启</p>
<p>打开 config.plist 文件并勾选 Acpi 部分的 FixShutdown 选项解决的</p>
</li>
<li><p>随航问题  目前高度怀疑是核显没激活</p>
</li>
</ul>
<p>BIOS 中设置主显卡为独显 (PCIE) 并且设置 DVMT 为 128M，以便独显、核显并存</p>
<p>enabling “Above 4G Decoding.”</p>
<p>bios设置主显卡为核显才能启动随航。</p>
<ul>
<li>引导界面多余选项</li>
</ul>
<p><a class="link"   href="https://blog.daliansky.net/OpenCore-BootLoader.html" >https://blog.daliansky.net/OpenCore-BootLoader.html<i class="fas fa-external-link-alt"></i></a>  find: Boot: 引导界面的设置</p>
<p><a class="link"   href="https://www.mfpud.com/topics/2984/" >https://www.mfpud.com/topics/2984/<i class="fas fa-external-link-alt"></i></a>   删除macOS黑苹果系统四叶草引导Clover启动界面的多余启动硬盘项</p>
<p>misc-security-scan policy 改为983299   Hideself改成TRUE</p>
<h1 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h1><ul>
<li>配置<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cpu: i7 8700 coffee lake</span><br><span class="line">graphics: MAXSUN RX580 2304 Polaris</span><br><span class="line">motherboard: Asus Z390-A</span><br><span class="line">ram: Micron 8g X2</span><br><span class="line">rom: WD sn550 500g X2</span><br></pre></td></tr></table></figure></li>
<li>BIOS 设置</li>
</ul>
<p><code>禁用</code></p>
<table>
<thead>
<tr>
<th>英文</th>
<th>中文</th>
</tr>
</thead>
<tbody><tr>
<td>Fast Boot</td>
<td>快速启动</td>
</tr>
<tr>
<td>CFG Lock (MSR 0xE2 write protection)</td>
<td>CFG 锁 (MSR 0xE2 写入保护)</td>
</tr>
<tr>
<td>VT-d</td>
<td><a class="link"   href="https://zhidao.baidu.com/question/495526512.html" >VT-d<i class="fas fa-external-link-alt"></i></a></td>
</tr>
<tr>
<td>CSM</td>
<td>兼容性支持模块</td>
</tr>
<tr>
<td>Intel SGX</td>
<td>Intel SGX</td>
</tr>
</tbody></table>
<p><code>启用</code></p>
<table>
<thead>
<tr>
<th>英文</th>
<th>中文</th>
</tr>
</thead>
<tbody><tr>
<td>VT-x</td>
<td><a class="link"   href="https://zhidao.baidu.com/question/495526512.html" >VT-x<i class="fas fa-external-link-alt"></i></a></td>
</tr>
<tr>
<td>Above 4G decoding</td>
<td>大于 4G 地址空间解码</td>
</tr>
<tr>
<td>Hyper Threading</td>
<td>处理器超线程</td>
</tr>
<tr>
<td>Execute Disable Bit</td>
<td>执行禁止位</td>
</tr>
<tr>
<td>EHCI/XHCI Hand-off</td>
<td>接手 EHCI/XHCI 控制</td>
</tr>
<tr>
<td>OS type: Other</td>
<td>操作系统类型: Other</td>
</tr>
<tr>
<td>Legacy RTC Device</td>
<td>传统 RTC 设备</td>
</tr>
<tr>
<td>restore on ac power loss</td>
<td>通电自启</td>
</tr>
<tr>
<td>打开 Ahci 选项</td>
<td></td>
</tr>
</tbody></table>
<h1 id="引导介绍"><a href="#引导介绍" class="headerlink" title="引导介绍"></a>引导介绍</h1><h2 id="EFI-文件结构"><a href="#EFI-文件结构" class="headerlink" title="EFI 文件结构"></a>EFI 文件结构</h2><p>打开下载好的最新版 OC，把 Doc 文件夹下面的 Sample.plist 改名为 config.plist，并把此文件移动到 EFI 目录下面。</p>
<p><code>EFI-OC-Kexts</code></p>
<p>打开 Kexts，我们把常用的一些 kexts 先放进去，一般情况下你需要放如下 Kexts:</p>
<table>
<thead>
<tr>
<th>文件名</th>
<th>解析</th>
</tr>
</thead>
<tbody><tr>
<td>Lilu.kext</td>
<td>Acidanthera驱动全家桶的SDK</td>
</tr>
<tr>
<td>Applealc.kext</td>
<td>声卡驱动</td>
</tr>
<tr>
<td>VirtualSMC.kext</td>
<td>传感器驱动依赖</td>
</tr>
<tr>
<td>SMCProcessor.kext</td>
<td>CPU核传感器</td>
</tr>
<tr>
<td>SMCSuperIO.kext</td>
<td>IO传感器</td>
</tr>
<tr>
<td>WhateverGreen.kext</td>
<td>显卡驱动</td>
</tr>
<tr>
<td>IntelMausi.kext</td>
<td>Intel类千兆网卡驱动</td>
</tr>
<tr>
<td>Usbinjectall.kext</td>
<td>USB驱动（你也可以定制自己的USB补丁）</td>
</tr>
<tr>
<td>NVMeFix.kext</td>
<td>为NVME硬盘增加ASPT属性来保证节电，虽然对台式机没啥用，但是官方推荐所有NVME用户都使用此补丁</td>
</tr>
</tbody></table>
<p><code>EFI-OC-Drives</code></p>
<p>打开Drives,里面的驱动介绍如下：</p>
<table>
<thead>
<tr>
<th>文件名</th>
<th>解析</th>
</tr>
</thead>
<tbody><tr>
<td>HfsPlus.efi</td>
<td>用于HFS格式文件系统，这是必须加载的。</td>
</tr>
<tr>
<td>OpenRuntime.efi</td>
<td>内存运用等必要的插件，必须加载。</td>
</tr>
<tr>
<td>MemoryAllocation.efi</td>
<td>为 Z390/X99 等主板预留第一组 512MB 内存, 帮助引导工具注入内核以及内核缓存至第一组 512MB 内存, 需要配合 FwRuntimeServices 和引导标识符 <code>slide=1</code> <a class="link"   href="https://blog.daliansky.net/OpenCore-BootLoader.html" >参考<i class="fas fa-external-link-alt"></i></a></td>
</tr>
<tr>
<td>OpenCanopy.efi</td>
<td>加载第三方开机主题。(目前没有主题)</td>
</tr>
</tbody></table>
<p>这个安装阶段中,要确保是从硬盘启动而不是 u盘. 从 u 盘启动将会重新开始最初的安装过程.</p>
<p>注：如果用的第三方制作的镜像，EFI分区可能已经有了EFI文件夹，请删除EFI分区内的所有文件后将你的EFI文件夹拖入到EFI分区</p>
<p>they released ACPI patch for our hacks to get native NVRAM (like older motherboards, only difference is in that we need additional .aml file in our EFIs). </p>
<p>U盘写好系统后,打开DiskGenius,把自己型号的clover复制到U盘的EFI文件夹替换原clover[^1]</p>
<ul>
<li>官方支持的其他文件</li>
</ul>
<p><strong>*<code>drivers</code>*文件夹下</strong></p>
<p><code>AppleUsbKbDxe.efi</code></p>
<blockquote>
<p>这个驱动是给使用模拟 UEFI 的老主板在 OpenCore 界面正常输入用的, 请勿在 Ivy Bridge (3 代酷睿)及以上的主板上使用 (详见 vit9696 的解释)</p>
</blockquote>
<p><code>NvmExpressDxe.efi</code></p>
<blockquote>
<p>用于在 Haswell (4 代酷睿) 或更老的主板上支持 NVMe 硬盘, 新主板不需要</p>
</blockquote>
<p><code>XhciDxe.efi</code></p>
<blockquote>
<p>用于给 Sandy Bridge (2 代酷睿) 或更老的主板上支持 XHCI, 新主板不需要</p>
</blockquote>
<p><code>HiiDatabase.efi</code></p>
<blockquote>
<p>用于给 Ivy Bridge (3 代酷睿) 或更老代主板上支持 UEFI 字体渲染, UEFI Shell 中文字渲染异常时使用, 新主板不需要</p>
</blockquote>
<p><code>AudioDxe.efi</code>  </p>
<blockquote>
<p>开机UEFI界面若需要声音效果需要加载。</p>
</blockquote>
<p><code>CrScreenshotDxe.efi </code></p>
<blockquote>
<p>开机UEFI的截图工具。</p>
</blockquote>
<p><code>OpenUsbKbDxe.efi </code></p>
<blockquote>
<p>给使用模拟 UEFI 的老主板在 OpenCore 界面正常输入用的, 请勿在 Ivy Bridge (3 代酷睿)及以上的主板上使用。</p>
</blockquote>
<p><code>Ps2KeyboardDxe.efi</code></p>
<blockquote>
<p>PS2键盘所需插件。</p>
</blockquote>
<p><code>Ps2MouseDxe.efi </code></p>
<blockquote>
<p>PS2鼠标所需插件。</p>
</blockquote>
<p><code>UsbMouseDxe.efi </code></p>
<blockquote>
<p>当MacOS被安装在虚拟机上所需要的鼠标插件。</p>
</blockquote>
<p><code>ACPIBatteryManager.kext</code></p>
<blockquote>
<p>电源管理驱动</p>
</blockquote>
<p><strong><em><code>tools</code></em></strong> <strong>文件夹下</strong></p>
<p><code>BootKicker.efi</code></p>
<blockquote>
<p>调用苹果原生的引导切换 GUI, 黑苹果不支持</p>
</blockquote>
<p><code>CleanNvram.efi</code></p>
<blockquote>
<p>OpenCore 自带的 NVRAM 清理功能已经足够我们使用</p>
</blockquote>
<p><code>GopStop.efi</code></p>
<blockquote>
<p>停止显卡 GOP, 排错时使用</p>
</blockquote>
<p><code>HdaCodecDump.efi</code></p>
<blockquote>
<p>导出声卡 Codec, 可用于定制声卡, 需要时可以临时加回来</p>
</blockquote>
<p><code>VerifyMsrE2.efi</code></p>
<blockquote>
<p>用于检查主板上 CFG 锁的状态</p>
</blockquote>
<p><img src="http://7.daliansky.net/OpenCore/Structure.png" alt="EFI文件结构"></p>
<p>现在, 我们可以把 AppleSupportPkg 中必需的 .efi 驱动程序放入 Drivers 文件夹, 将 你的 kext 和 DSDT/SSDT 放入各自的文件夹中。请注意, OpenCore 不支持支持列表以外的 UEFI 驱动程序!</p>
<h2 id="config-plist介绍"><a href="#config-plist介绍" class="headerlink" title="config.plist介绍"></a>config.plist介绍</h2><p><strong>PollAppleHotKeys:</strong> <code>YES</code></p>
<p>设置为 YES 后允许在<strong>引导过程</strong>中使用苹果原生快捷键, 需要与 Quirk KeySupport=Yes 结合使用, 具体体验取决于主板固件。</p>
<p>快捷键组合:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Cmd + V: 启用 -v 跑码</span><br><span class="line">Cmd + Opt + P + R: 重置 NVRAM</span><br><span class="line">Cmd + R: 启动恢复分区</span><br><span class="line">Cmd + S: 启动至单用户模式</span><br><span class="line">Option &#x2F; ALT: 在 ShowPicker 设置成 NO 时显示引导项选择界面, ALT 不可用时可用 ESC 键代替</span><br><span class="line">Cmd + C + 减号: 关闭主板兼容性检查, 等同于添加引导标识符 -no_compat_check</span><br><span class="line">Shift: 安全模式</span><br></pre></td></tr></table></figure>
<h1 id="安装原理"><a href="#安装原理" class="headerlink" title="安装原理"></a>安装原理</h1><h2 id="使用的软件"><a href="#使用的软件" class="headerlink" title="使用的软件"></a>使用的软件</h2><p> clover 引导启动系统<br> opencore 引导启动系统</p>
<h2 id="系统引导原理"><a href="#系统引导原理" class="headerlink" title="系统引导原理"></a>系统引导原理</h2><ol>
<li>白苹果： 电脑加电 → 启动 Mac 的 UEFI Bios → 加载 NVRAM → 进入 macOS</li>
<li>clover: 电脑加电 → 加载四叶草的 EFI 微系统 → 模拟白果的 EFI 和加载参数 → 进入 macOS</li>
<li>Ozmosis：电脑加电 → 启动 Ozmosis 模拟的 Mac 的 Uefi Bios → 加载 NVRAM → 进入 macOS</li>
</ol>
<p>Clover的引导方式是通过用户创建EFI分区来引导仿冒的设备信息，从而实现系统的安装，但是由于Clover是通过仿冒白苹果机型来完成安装，所以必须要求所安装的黑苹果硬件和白苹果相似。</p>
<p>opencore引导是clover的升级版，它相较于Clover的最大优势就是，它在mac升级系统的时候只需要升级kexts驱动文件即可，不必要升级OC引导本身</p>
<p>Oz（<a class="link"   href="http://imacosx.com/scb/1886.html" >Ozmosis<i class="fas fa-external-link-alt"></i></a>）引导，通过将BIOS刷成和白果一样达到完美效果，不过这种方法兼容性差，容易把主板刷报废，目前已经不更新了。</p>
<h1 id="收集的一些坑经验"><a href="#收集的一些坑经验" class="headerlink" title="收集的一些坑经验"></a>收集的一些<del>坑</del>经验</h1><p>分区文件DiskGenius  下一个稳定版本的 不然很容易报错<br>TransMac 这个软件 下一个绿色版的 试用版的容易出错  我就是出错了 然后就挂了 又一次下载镜像   建议使用 balenaEtcher</p>
<blockquote>
<p>Every motherboard has NVRAM, but Intel 300 series (except z370) like B360, Z390, H370, etc. has other implementation of it that previous motherboards and that’s why we needed emulated nvram for nice hackintoshy stuff.<br>they released ACPI patch for our hacks to get native NVRAM (like older motherboards, only difference is in that we need additional .aml file in our EFIs). (<a class="link"   href="https://www.reddit.com/r/hackintosh/comments/ercqom/native_nvram_on_z390_possible/" >https://www.reddit.com/r/hackintosh/comments/ercqom/native_nvram_on_z390_possible/<i class="fas fa-external-link-alt"></i></a>)</p>
</blockquote>
<p>所有AMD免驱显卡均建议搭配Lilu.kext和WhateverGreen.kext使用，以避免启动黑屏、流处理器被部分禁用、显存不识别等毛病，其它原因同NVIDIA显卡；</p>
<p>AMD 显卡在黑苹果中免驱，指的是只要把这个显卡插上，搭配 WhateverGreen.kext （下称“WEG”）的情况下 macOS 就能识别出对应的型号，并提供基础性能驱动。其实这个时候，WEG 仅仅只是调用了针对某一核心架构的通用驱动，例如 RX470/RX570/RX580 核心都是 Polaris，RX5500/RX5600/RX5700XT 核心都是 Navi，WEG 分别调用了针对某一核心的通用驱动，实现了基本驱动和基本性能。</p>
<p>但是。这里要说但是了。</p>
<p>这样的驱动并不能发挥显卡最大的性能，举几个实际案例：在 Geekbench 的性能测试中，Radeon VII 的得分仅为 5-6 万分，而在 Windows 上可以轻松达到 8.2 万分以上；Radeon RX 5700XT 的 Metal 性能得分大概是 3.8 万分左右，而在解决这个问题后能轻松跑到 6.4 万分以上（macOS 10.15.4 以后能达到 7 万分以上），并且在超频后差距更大。<br><em>称为 SMU 的固件（SMU Firmware）</em>  针对这个情况，可以使用由 @CMMChris 开发的第三方驱动 RadeonBoost.kext<br>如果使用后黑屏，请添加 adgpmod=pikera 这个启动参数</p>
<p>参考：</p>
<p><a class="link"   href="https://heipg.cn/tutorial/graphic-card-for-macos-2020.html" >2020年黑苹果macOS Catalina显卡支持列表，持续更新中<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://heipg.cn/tutorial/fix-smu-firmware-for-radeon.html" >修复SMU固件引起的显卡问题<i class="fas fa-external-link-alt"></i></a></p>
<h2 id="常见问题及解决方案"><a href="#常见问题及解决方案" class="headerlink" title="常见问题及解决方案"></a>常见问题及解决方案</h2><h3 id="MacOS-与-Windows-时间不一致"><a href="#MacOS-与-Windows-时间不一致" class="headerlink" title="MacOS 与 Windows 时间不一致"></a>MacOS 与 Windows 时间不一致</h3><p>Windows 管理员运行cmd 输入命令：Reg add HKLM\SYSTEM\CurrentControlSet\Control\TimeZoneInformation /v RealTimeIsUniversal /t REG_DWORD /d 1</p>
<p>原因：Windows 与Mac计算时间方式不同，Windows直接读取UTF时间，Mac自动UTF+8</p>
<h3 id="开机显示American-Megatrends"><a href="#开机显示American-Megatrends" class="headerlink" title="开机显示American Megatrends"></a>开机显示American Megatrends</h3><img src="https://i.loli.net/2020/12/31/QJc7kYuSb6tqNnX.png" alt="image.png" style="zoom:50%;" />

<p>config.plist-&gt;NVRAM-&gt;Add-&gt;7C436110-AB2A-4BBB-A880-FE41995C9F82-&gt;boot-args<br>添加字段  rtcfx_excloud=80-FF  从00-FF 自己试</p>
<h3 id="Open-Core-默认选项无法修改"><a href="#Open-Core-默认选项无法修改" class="headerlink" title="Open Core 默认选项无法修改"></a>Open Core 默认选项无法修改</h3><p>Apple -&gt; System Preferences -&gt; Startup Disk  设置MacOS 启动盘为启动项<br>在 Open Core 中选择你想设为默认的系统 Ctrl+Enter 即可</p>
<h3 id="bios-黑屏-可正常进系统"><a href="#bios-黑屏-可正常进系统" class="headerlink" title="bios 黑屏 可正常进系统"></a>bios 黑屏 可正常进系统</h3><p>clean nvram 即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Hi, i&#39;m back. I cleaned the NVRAM, after that I accidentally pushed the &quot;del&quot; key and the BIOS page has appeared.</span><br><span class="line"></span><br><span class="line">Im theory yes CMD + ALT + P + R, but I use OpenCore as boot loader and there is an option for that.</span><br><span class="line"></span><br><span class="line">You can try using terminal:</span><br><span class="line"></span><br><span class="line">sudo nvram -c</span><br><span class="line"></span><br><span class="line">sudo shutdown -r now</span><br><span class="line"></span><br><span class="line">Restart the PC and try to access BIOS.</span><br><span class="line"></span><br><span class="line">Let me know.</span><br></pre></td></tr></table></figure>
<h3 id="音频输出"><a href="#音频输出" class="headerlink" title="音频输出"></a>音频输出</h3><p>Config–DeviceProperties</p>
<p>此项是用来注入你的设备的，主要是显卡和声卡两部分。同样你也可以定制一些设备到你的 <code>关于本机--系统报告--PCI</code> 列表中，尽管没有多大的意义。</p>
<p>声卡</p>
<p>这里首先我们需要确认自己的声卡驱动已经被加载，终端下输入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kextstat | grep -E <span class="string">&quot;AppleHDA|AppleALC|Lilu&quot;</span></span><br></pre></td></tr></table></figure>
<p>我们会得到被加载的驱动，请确保 <code>as.vit9696.Lilu</code>；<code>as.vit9696.AppleALC</code>；<code>com.apple.driver.AppleHDAController</code>；<code>com.apple.driver.AppleHDA</code> 已经被加载。</p>
<p>找自己声卡的地址，准备好在文章开头要求下载的 <code>gfxutil</code>，将 <code>gfxutil</code> 程序放在桌面，输入:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~/desktop/gfxutil -f HDEF //一般来说我们在使用 Applealc 后，板载声卡的部件名都叫 HDEF</span><br></pre></td></tr></table></figure>
<p>我们输入后会得到声卡的PCI路径，比如我输出的就是：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">00:1f.3 8086:a2f0 /PC00@0/HDEF@1F,3 = PciRoot(0x0)/Pci(0x1F,0x3)</span><br></pre></td></tr></table></figure>
<p>这里我们找到的声卡 PCI 路径为 <code>PciRoot(0x0)/Pci(0x1f,0x3)</code>。我们把预先填写在那里的 <code>PciRoot(0x0)/Pci(0x1b,0x0)</code> 项替换成我们真正的声卡路径。</p>
<p>后面一段我们看到预先填写的声卡ID为 <code>&lt;01000000&gt;</code>，这里我们需要把它换成合适自己声卡的 ID，输入以下命令得到自己声卡的 CodecID。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ioreg -l|grep IOHDACodecVendorID</span><br></pre></td></tr></table></figure>
<p>点击<a class="link"   href="https://github.com/headkaze/Hackintool/blob/master/Resources/Audio/Codecs.plist" >此页面<i class="fas fa-external-link-alt"></i></a>搜索刚得到的CodecID就可查询到自己声卡的型号名称，以及可用的 <code>LayoutID</code>。</p>
<p>比如我的 CodecID 为 <code>283906408</code>，声卡型号 <code>ALCS1220A</code>，对应 1, 2, 3, 5, 7, 11, 13, 15, 16, 27, 28, 29, 34 的 <code>layout ID</code>。我们需要一个个测试过去，选定自己能用的。这里我们选择 7 这个 ID 进行测试，将 7 转化成 16 进制格式为 07，后面为了满足格式要求添加 6 个 0，则为 <code>07000000</code>，将这个值替换刚才预先填的<code> 01000000</code> 中；如果我们测试 ID 为 27，27 的 16 进制为 1b，补上 6 个 0 则为 <code>1b000000</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PciRoot(0x0)&#x2F;Pci(0x1f,0x3)</span><br><span class="line">        device-id       data      &lt;70a10000&gt; &#x2F;&#x2F;一般情况下这段是不需要填写的，除非你的声卡需要仿冒</span><br><span class="line">        layout-id       data      &lt;0b000000&gt; &#x2F;&#x2F;这个Layout id我瞎写的，你按实际情况写</span><br></pre></td></tr></table></figure>
<p>如果你测试的ID都无效，请确保你的操作过程正确、并测试用万能声卡(VoodooHDA)补丁来替换 AppleALC 这个补丁。如果都不行，你可能需要自行<a class="link"   href="https://blog.daliansky.net/Use-AppleALC-sound-card-to-drive-the-correct-posture-of-AppleHDA.html" >编译声卡补丁<i class="fas fa-external-link-alt"></i></a>。</p>
<p>参考：<a class="link"   href="https://blog.xjn819.com/post/opencore-guide.html" >2.3 Config–DeviceProperties<i class="fas fa-external-link-alt"></i></a></p>
<h2 id="Mac与Win的差异"><a href="#Mac与Win的差异" class="headerlink" title="Mac与Win的差异"></a>Mac与Win的差异</h2><h3 id="引导方式"><a href="#引导方式" class="headerlink" title="引导方式"></a>引导方式</h3><ul>
<li><strong>Windows</strong></li>
</ul>
<p>主要的系统引导方式有两种：传统的Legacy BIOS 和新型的 UEFI BIOS</p>
<p><strong><em>Legacy BIOS</em></strong></p>
<p>无法识别GPT分区表格式</p>
<p><strong><em>UEFI BIOS</em></strong></p>
<p>UEFI是一个微型操作系统，放在固件中，能识别FAT文件系统，运行efi程序</p>
<p>可同时识别MBR分区和GPT分区，都可用于启动操作系统。</p>
<blockquote>
<p>Boot Loader：</p>
<p>对于PC平台来说Boot Loader=BIOS+启动管理器+启动文件+载入程序（IPL+SPL），但是一般指启动管理器及启动设置文件。<br>功能：启动管理器+启动设置文件：提供启动选项，定位、加载并执行SPL。<br>SPL：加载OS内核，SPL只认识自己分区的内核文件。</p>
</blockquote>
<p><strong><em>Legacy BIOS+MBR引导原理</em></strong></p>
<p>引导过程：上电–&gt;Legacy BIOS–&gt;MBR–&gt;DPT–&gt;PBR–&gt; Bootmgr（vista开始）/NTLDR–&gt;BCD（vista开始）/boot.ini–&gt;Winload.exe–&gt;内核加载 –&gt;windows vista/windows xp</p>
<p><strong><em>UEFI BIOS+GPT 引导原理</em></strong></p>
<p>引导过程：上电–&gt;UEFI–&gt;GPT分区表–&gt;EFI分区–&gt;\efi\Microsoft\boot\bootmgfw.efi–&gt;efi\Microsoft\BCD→\Windows\system32\winload.efi。</p>
<ul>
<li><strong>MacOS</strong></li>
</ul>
<p>参考：<br><a class="link"   href="https://blog.csdn.net/liao20081228/article/details/82591728" >windows引导过程以及多系统引导原理<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://www.jianshu.com/p/26e184605952" >初步了解计算机与操作系统启动原理<i class="fas fa-external-link-alt"></i></a></p>
<p>[^1]:???遗留笔记  应该没啥大用</p>
]]></content>
      <tags>
        <tag>hackintosh</tag>
        <tag>efi</tag>
        <tag>系统</tag>
      </tags>
  </entry>
  <entry>
    <title>VScode使(偷)用(懒)技(指)巧(南)</title>
    <url>/2020/12/31/VScodeSkill/</url>
    <content><![CDATA[<h1 id="vs-code整段右移或者左移"><a href="#vs-code整段右移或者左移" class="headerlink" title="vs code整段右移或者左移"></a>vs code整段右移或者左移</h1><p>选中按TAB右移，按SHIFT+TAB左移</p>
<h1 id="在VScode中使用C-开发"><a href="#在VScode中使用C-开发" class="headerlink" title="在VScode中使用C#开发"></a>在VScode中使用C#开发</h1><p>VScode仅限于微型项目或测试  写项目还是老老实实用Visual Studio吧！</p>
<p><strong>环境</strong></p>
<ul>
<li>VSC本体</li>
<li>.NET Core SDK，可以访问dot.net下载</li>
<li>VSC扩展：C#、Code Runner</li>
</ul>
<p><strong>操作步骤</strong></p>
<ul>
<li>建立一个空文件夹</li>
<li>打开终端（TERMINAL） 输入<code> dotnet new console</code> 会自动生成Hello World文件</li>
<li>按F5即可运行 </li>
<li>还需要做一点修改。左边点开.vscode文件夹：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">launch.json：&quot;console&quot;: &quot;integratedTerminal&quot;, &quot;internalConsoleOptions&quot;: &quot;neverOpen&quot;;  .NET Core Attach可以删掉。</span><br><span class="line">tasks.json：给build加上&quot;group&quot;: &#123; &quot;kind&quot;: &quot;build&quot;, &quot;isDefault&quot;: true &#125;,（打group就&gt;会自动提示）</span><br></pre></td></tr></table></figure>
如使用runner 需要设置环境变量<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">csc是编译C#的程序。安装VS，把 安装路径下\Microsoft VisualStudio</span><br><span class="line">\2019\Community\MSBuild\Current\Bin\Roslyn\加到Path里。</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>常见问题</strong></p>
<p><code>&#39;scriptcs&#39; is not recognized as an internal or external command, operable program or batch file.</code></p>
<blockquote>
<p>You need both the script runner extension and to install scripts</p>
<p>Installation and information guide is here: <a class="link"   href="http://scriptcs.net/" >http://scriptcs.net/<i class="fas fa-external-link-alt"></i></a></p>
<ol>
<li>Install chocolatey</li>
<li>Run <code>cinst scriptcs</code> to install the latest version.</li>
</ol>
</blockquote>
<p><a class="link"   href="https://stackoverflow.com/questions/59261688/trouble-running-c-sharp-code-in-vs-code-getting-scriptcs-error" >refer<i class="fas fa-external-link-alt"></i></a></p>
<p><code>error CS7021: You cannot declare namespace in script code</code></p>
<blockquote>
<p>It’s complaining about the namespace, so remove it from the Program.cs</p>
</blockquote>
<p><code>The name &#39;Console&#39; does not exist in the current context</code></p>
<p>using System;</p>
<p><code>Feature &#39;default literal&#39; is not available in C# 8.0. Please use language version 9.0 or greater.</code></p>
<blockquote>
<p>Adding</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;LangVersion&gt;latest&lt;&#x2F;LangVersion&gt;</span><br></pre></td></tr></table></figure>

<p> under the <code>&lt;PropertyGroup&gt;</code> tags</p>
<p>in your pubxml(**.csproj) file seems to fix it.</p>
</blockquote>
<p><a class="link"   href="https://stackoverflow.com/questions/47946732/c-sharp-7-1-cant-be-published/48085575#48085575" >refer<i class="fas fa-external-link-alt"></i></a></p>
<h1 id="VS-code-同步设置和扩展插件"><a href="#VS-code-同步设置和扩展插件" class="headerlink" title="VS code 同步设置和扩展插件"></a>VS code 同步设置和扩展插件</h1><p><a class="link"   href="https://www.jianshu.com/p/0a273bf2a986" >https://www.jianshu.com/p/0a273bf2a986<i class="fas fa-external-link-alt"></i></a><br>vscode_plugin token ebc81cc8b0dac29cdbc8e98d5eef49094f5d7e5c<br>gist :e813379a55dab2b9a6d2bc13e1bbf8f0</p>
<p>int是带符号的，表示范围是：-2147483648到2147483648，即-2^31到2^31次方。</p>
<p>uint则是不带符号的，表示范围是：2^32即0到4294967295。</p>
]]></content>
      <tags>
        <tag>VScode</tag>
      </tags>
  </entry>
  <entry>
    <title>Win和Mac使(偷)用(懒)指(技)南(巧)</title>
    <url>/2020/12/31/Win&amp;MacSkill/</url>
    <content><![CDATA[<h1 id="Win"><a href="#Win" class="headerlink" title="Win"></a>Win</h1><h2 id="如何快速格式化硬盘-Win"><a href="#如何快速格式化硬盘-Win" class="headerlink" title="如何快速格式化硬盘 Win"></a>如何快速格式化硬盘 <code>Win</code></h2><ol>
<li>打开cmd</li>
<li>输入diskpart</li>
<li> <img src="https://i.loli.net/2020/12/31/DLGR69srZchzKTI.png" alt="image.png" style="zoom: 50%;" />

</li>
</ol>
<h2 id="PowerToys使用指南"><a href="#PowerToys使用指南" class="headerlink" title="PowerToys使用指南"></a>PowerToys使用指南</h2><ul>
<li><ol>
<li>spotlight：<code>Alt+space</code></li>
</ol>
</li>
<li><ol start="2">
<li>Windows 快捷键说明：<code>长按Windows键3秒</code></li>
</ol>
</li>
</ul>
<h1 id="Mac"><a href="#Mac" class="headerlink" title="Mac"></a>Mac</h1><h2 id="显示隐藏文件"><a href="#显示隐藏文件" class="headerlink" title="显示隐藏文件"></a>显示隐藏文件</h2><h3 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h3><p>cmd+shift+.</p>
<h3 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h3><p>//显示隐藏文件<br>defaults write com.apple.finder AppleShowAllFiles -bool true<br>//不显示隐藏文件<br>defaults write com.apple.finder AppleShowAllFiles -bool false</p>
<p>需要重启Finder：窗口左上角的苹果标志–&gt;强制退出–&gt;Finder–&gt;重新启动</p>
<h2 id="显示文件路径"><a href="#显示文件路径" class="headerlink" title="显示文件路径"></a>显示文件路径</h2><p>使用终端命令行显示完整路径</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">defaults write com.apple.finder _FXShowPosixPathInTitle -bool TRUE;killall Finder</span><br></pre></td></tr></table></figure>
<p>隐藏完整路径</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">defaults delete com.apple.finder _FXShowPosixPathInTitle;killall Finder</span><br></pre></td></tr></table></figure>
<h2 id="程序坞放大效果"><a href="#程序坞放大效果" class="headerlink" title="程序坞放大效果"></a>程序坞放大效果</h2><p>程序坞设置 勾选放大</p>
<h2 id="键盘映射"><a href="#键盘映射" class="headerlink" title="键盘映射"></a>键盘映射</h2><p>键盘-&gt;修饰键  option和command互换</p>
<h2 id="触发角"><a href="#触发角" class="headerlink" title="触发角"></a>触发角</h2><p>系统偏好设定——&gt; Mission Control——&gt; 触发脚…——&gt; 在右下角选择“桌面” ——&gt; 搞定。</p>
<h2 id="自动挂载EFI文件"><a href="#自动挂载EFI文件" class="headerlink" title="自动挂载EFI文件"></a>自动挂载EFI文件</h2><p>使用命令<code>diskutil list</code>找到EFI所在的分区</p>
<p><img src="https://i.loli.net/2020/11/24/FlZaNjwgGMW3Oms.png" alt="image.png"></p>
<p>获取EFI分区UUID<code>sudo diskutil info disk0s1 | grep &#39;Partition UUID&#39;</code></p>
<p><img src="https://i.loli.net/2020/11/24/xLbvwNAD9hMd5T1.png" alt="diskutil info"></p>
<p>F9399EFF-E7E7-42CB-A352-A285E6FC61FA</p>
<p>打开系统自带的自动操作程序，依次点击应用程序 -&gt; 选取 -&gt; 运行 shell 脚本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line"></span><br><span class="line">mountEFI&#x3D;$(echo &#39;你的密码&#39; | sudo -S diskutil info 你的UUID | grep &#39;Device Node&#39;)</span><br><span class="line">echo &#39;你的密码&#39; | sudo -S diskutil mount &#39;&#x2F;&#39;$&#123;mountEFI#*&#x2F;&#125;</span><br><span class="line">open &#x2F;Volumes&#x2F;EFI&#x2F;EFI&#x2F;OC</span><br></pre></td></tr></table></figure>
<p>将以上代码写入，保存即可<br><img src="https://i.loli.net/2020/11/24/UTRn57Et3i4brLp.png" alt="image.png"></p>
<p>参考：<a class="link"   href="https://www.bugprogrammer.me/2019/12/03/mountEFI.html" >https://www.bugprogrammer.me/2019/12/03/mountEFI.html<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
      <tags>
        <tag>系统</tag>
        <tag>Win</tag>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title>Git总结</title>
    <url>/2020/12/02/git/</url>
    <content><![CDATA[<h1 id="git-remote"><a href="#git-remote" class="headerlink" title="git remote"></a>git remote</h1><h2 id="查看远程分支"><a href="#查看远程分支" class="headerlink" title="查看远程分支"></a>查看远程分支</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure>
<h1 id="git-branch"><a href="#git-branch" class="headerlink" title="git branch"></a>git branch</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch <span class="comment">## 查看当前所在分支</span></span><br></pre></td></tr></table></figure>
<h2 id="新建分支"><a href="#新建分支" class="headerlink" title="新建分支"></a>新建分支</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch aaa</span><br></pre></td></tr></table></figure>
<p>建议使用[git switch](#git switch)</p>
<h2 id="本地分支与远程关联"><a href="#本地分支与远程关联" class="headerlink" title="本地分支与远程关联"></a>本地分支与远程关联</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch --set-upstream-to=origin/&lt;branch Name&gt; &lt;branch Name&gt;</span><br></pre></td></tr></table></figure>
<p>若出现错误<code>fatal: branch &#39;master&#39; does not exist</code>原因为本地无分支 新建并checkout 到该分支，再执行此方法，还不行就执行一遍git fetch origin</p>
<h2 id="取消与远程关联"><a href="#取消与远程关联" class="headerlink" title="取消与远程关联"></a>取消与远程关联</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch --unset-upstream</span><br></pre></td></tr></table></figure>
<p>取消与远程仓库的关联<code>git remote remove origin</code></p>
<h2 id="删除本地分支"><a href="#删除本地分支" class="headerlink" title="删除本地分支"></a>删除本地分支</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch -d &lt;branch name&gt;</span><br></pre></td></tr></table></figure>
<h2 id="查看远程分支-1"><a href="#查看远程分支-1" class="headerlink" title="查看远程分支"></a>查看远程分支</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch -a</span><br></pre></td></tr></table></figure>


<h1 id="git-checkout"><a href="#git-checkout" class="headerlink" title="git checkout"></a>git checkout</h1><h2 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout aaa <span class="comment"># 切换到 aaa分支</span></span><br><span class="line">git checkout -b aaa <span class="comment"># 创建aaa，然后切换到 aaa分支</span></span><br><span class="line">git checkout commitid <span class="comment"># 切换到某个commit id</span></span><br></pre></td></tr></table></figure>
<h2 id="丢弃本地所有修改，不包括新增文件"><a href="#丢弃本地所有修改，不包括新增文件" class="headerlink" title="丢弃本地所有修改，不包括新增文件"></a>丢弃本地所有修改，不包括新增文件</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout . //本地所有修改的。没有的提交的，都返回到原来的状态</span><br></pre></td></tr></table></figure>
<h1 id="git-switch"><a href="#git-switch" class="headerlink" title="git switch"></a>git switch</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git switch aaa <span class="comment"># 切换到 aaa分支</span></span><br><span class="line">git switch -c aaa <span class="comment"># 创建aaa，然后切换到 aaa分支</span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>管理分支</th>
<th>git branch</th>
<th>git branch</th>
</tr>
</thead>
<tbody><tr>
<td>切换分支</td>
<td>git checkout</td>
<td>git switch</td>
</tr>
<tr>
<td>新建+切换分支</td>
<td>git checkout -b</td>
<td>git switch -c</td>
</tr>
<tr>
<td>切换到commit id</td>
<td>git checkout</td>
<td>git checkout</td>
</tr>
</tbody></table>
<h1 id="git-restore"><a href="#git-restore" class="headerlink" title="git restore"></a>git restore</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git restore [--worktree] aaa <span class="comment"># 从staged中恢复aaa到worktree</span></span><br><span class="line">git restore --staged aaa <span class="comment"># 从repo中恢复aaa到staged</span></span><br><span class="line">git restore --staged --worktree aaa <span class="comment"># 从repo中恢复aaa到staged和worktree</span></span><br><span class="line">git restore --<span class="built_in">source</span> dev aaa <span class="comment"># 从指定commit中恢复aaa到worktree</span></span><br></pre></td></tr></table></figure>
<img src="https://i.loli.net/2020/12/30/APhoDGuC1TQw2Oy.png" alt="542.png" style="zoom:67%;" />

<h1 id="git-stash"><a href="#git-stash" class="headerlink" title="git stash"></a>git stash</h1><p>可以将本地还没有提交的改动全部存储起来 并不提交</p>
<h2 id="git-stash-apply-git-stash-pop"><a href="#git-stash-apply-git-stash-pop" class="headerlink" title="git stash apply / git stash pop"></a>git stash apply / git stash pop</h2><p>这两个命令就可以将刚才暂存起来的内容还原了。但是这里有一个问题，就是 stash apply 和 pop 之间是不同的。<br>这里涉及到 stash 内部的实现机制，stash 内部其实是通过堆栈实现的。pop 对于堆栈而言很明确，就是弹出的意思。也就是说如果我们使用的是 pop，那么当我们 pop 之后，这条记录会在堆栈当中删除。而如果使用的是 apply 呢，记录不会从堆栈当中删除，仍然会保留下来。<br>一般情况下我使用 pop 多一些，但是 pop 也有缺点，比如 pop 没有办法选择应用的记录。我们可以使用 git stash list 来查看一下当前堆栈当中已经有的记录。<br>如果我们使用 git stash pop 的话，默认的是应用的栈顶的记录，也就是 stash@{0}。但如果我们使用 stash apply 的话，我们可以自由选择我们想要应用的记录。比如如果我们想要应用最后一条记录的话，我们可以这样：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git stash apply stash@&#123;2&#125;</span><br></pre></td></tr></table></figure>
<p>清空<code>git stash clear</code> 删除某个<code>git stash drop stash@&#123;0&#125;  </code></p>
<p>脚注示范<a href="%E8%BF%99%E6%98%AF%E8%A7%A3%E9%87%8A">^1</a></p>
<h1 id="git-diff"><a href="#git-diff" class="headerlink" title="git diff"></a>git diff</h1><p>查看当前文件的改动信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git diff &lt;filename&gt;</span><br></pre></td></tr></table></figure>
<p>查看改动文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git diff --<span class="built_in">stat</span> </span><br></pre></td></tr></table></figure>
<p>查看与另一分支的差别</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git diff &lt;branch&gt; &lt;filename&gt;</span><br></pre></td></tr></table></figure>
<p>查看与暂存仓库的差别</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git diff --cached &lt;commit&gt; &lt;filename&gt;</span><br></pre></td></tr></table></figure>
<p>查看与远程仓库的差别</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git diff &lt;commit&gt; &lt;filename&gt;</span><br></pre></td></tr></table></figure>
<p><code>&lt;cmmit&gt;</code>=<code>HEAD</code>时查看工作目录同最近一次 commit 的内容的差异。</p>
<p>两次commit之间的差别</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git diff &lt;commit&gt; &lt;commit&gt;</span><br></pre></td></tr></table></figure>
<p>以上命令可以不指定 <code>&lt;filename&gt;</code>，则对全部文件操作。<br> 以上命令涉及和 Git仓库 对比的，均可指定 commit 的版本。</p>
<ul>
<li><code>HEAD</code> 最近一次 commit</li>
<li><code>HEAD^</code>  上次提交</li>
<li><code>HEAD~100</code> 上100次提交</li>
<li>每次提交产生的哈希值<h1 id="git-add"><a href="#git-add" class="headerlink" title="git add"></a>git add</h1>git add .</li>
</ul>
<p>不加参数默认为将修改操作的文件和未跟踪新添加的文件添加到git系统的暂存区，注意不包括删除</p>
<p>git add -u</p>
<p>-u == –update 表示将已跟踪文件中的修改和删除的文件添加到暂存区，不包括新增加的文件，注意这些被删除的文件被加入到暂存区再被提交并推送到服务器的版本库之后这个文件就会从git系统中消失了</p>
<p>git add -A</p>
<p>-A == –all </p>
<p>表示将所有的已跟踪的文件的修改与删除和新增的未跟踪的文件都添加到暂存区。</p>
<p>git add -I 不常用</p>
<h2 id="撤销add"><a href="#撤销add" class="headerlink" title="撤销add"></a>撤销add</h2><p>如果是某个文件回滚到上一次操作：  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git reset HEAD  文件名</span><br></pre></td></tr></table></figure>
<p><strong>撤销</strong> <strong>add**</strong>操作**</p>
<p>可以直接使用命令  <strong>git reset HEAD</strong></p>
<p>这个是整体回到上次一次操作</p>
<p><strong>绿字变红字</strong> <strong>(撤销add)</strong></p>
<p>如果是某个文件回滚到上一次操作： <strong>git reset HEAD</strong> <strong>文件名</strong></p>
<h2 id="批量添加-（不是add-）"><a href="#批量添加-（不是add-）" class="headerlink" title="批量添加 （不是add .）"></a>批量添加 （不是add .）</h2><p>在工作中，使用add . 的情况反而不是最多的，工作区有很多文件不能提交到仓库里，一般情况下需要我们一个一个添加，你的目的是要添加所有的还是需要一种方式添加你需要添加的，如果是前一种 <code>git add .</code> 就可以</p>
<p>如果这里还有特殊情况 比如一半需要添加一半不需要 使用 <code>git add -i</code> 进入交互式添加</p>
<img src="https://i.loli.net/2020/12/30/qAfQ2WjIslnpaOK.png" alt="image-20201217171840684.png" style="zoom:67%;" />

<img src="https://i.loli.net/2020/12/30/GXfs6C7Si9oTvdh.png" alt="image-20201217171922907.png" style="zoom:67%;" />

<img src="https://i.loli.net/2020/12/30/Jfi4WSl5VQmt9XY.png" alt="image-20201217171948829.png" style="zoom:67%;" />

<img src="https://i.loli.net/2020/12/30/KvG8Bc3lr2nhUmZ.png" alt="image-20201217172008565.png" style="zoom:67%;" />

<h1 id="git-pull"><a href="#git-pull" class="headerlink" title="git pull"></a>git pull</h1><p>默认拉取远程已绑定的分支到当前分支</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//与这两句等价</span><br><span class="line">git fetch origin master //从远程主机的master分支拉取最新内容 </span><br><span class="line">git merge FETCH_HEAD    //将拉取下来的最新内容合并到当前所在的分支中</span><br></pre></td></tr></table></figure>
<p>取回<code>origin</code>主机的<code>fixbug</code>分支的最新提交，<strong>并与本地的<code>master</code>分支合并</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git pull origin &lt;remotebranshname&gt;:&lt;localbranshname&gt;</span><br></pre></td></tr></table></figure>
<p>指定远程分支与当前分支合并</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git pull origin &lt;remotebranshname&gt;</span><br></pre></td></tr></table></figure>
<img src="https://i.loli.net/2020/12/30/MrpnYvLAG6jzXiW.jpg" alt="clip_image001.jpg" style="zoom:50%;" />

<p>详情参考[git pull/fetch详解](# git fetch &amp; pull详解)</p>
<h1 id="git-push"><a href="#git-push" class="headerlink" title="git push"></a>git push</h1><p>当前分支只有一个远程分支 可用此命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure>
<p>如果远程分支被省略，如上则表示将本地分支推送到与之存在追踪关系的远程分支（通常两者同名），如果该远程分支不存在，则会被新建</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push origin : refs/<span class="keyword">for</span>/master </span><br></pre></td></tr></table></figure>
<p>如果省略本地分支名，则<strong>表示删除指定的远程分支</strong>，因为这等同于推送一个空的本地分支到远程分支，等同于 git push origin –delete master</p>
<p>git push origin</p>
<p>如果当前分支与远程分支存在追踪关系，则本地分支和远程分支都可以省略，将当前分支推送到origin主机的对应分支</p>
<p> git push的一般形式为 git push &lt;远程主机名&gt; &lt;本地分支名&gt;  &lt;远程分支名&gt; ，例如 git push origin master：refs/for/master ，即是将本地的master分支推送到远程主机origin上的对应master分支， origin 是远程主机名，第一个master是本地分支名，第二个master是远程分支名。</p>
<h2 id="撤销push操作"><a href="#撤销push操作" class="headerlink" title="撤销push操作"></a>撤销push操作</h2><p>重置至指定版本的提交，达到撤销提交的目的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git reset –-soft &lt;版本号&gt;</span><br></pre></td></tr></table></figure>
<h1 id="git-commit"><a href="#git-commit" class="headerlink" title="git commit"></a>git commit</h1><h2 id="使用amend命令修改commit信息"><a href="#使用amend命令修改commit信息" class="headerlink" title="使用amend命令修改commit信息"></a>使用amend命令修改commit信息</h2><p>(注： amend命令只会修改最后一次commit的信息，之前的commit需要使用rebase）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git commit --amend --reset-author</span><br></pre></td></tr></table></figure>
<h2 id="撤销commit"><a href="#撤销commit" class="headerlink" title="撤销commit"></a>撤销commit</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git reset --soft HEAD~1  &#x2F;&#x2F;windows的bash</span><br></pre></td></tr></table></figure>
<h2 id="查看提交历史记录"><a href="#查看提交历史记录" class="headerlink" title="查看提交历史记录"></a>查看提交历史记录</h2><p><em>git log</em></p>
<p>查看所有的commit提交记录</p>
<p>加上参数  –pretty=oneline，只会显示版本号和提交时的备注信息</p>
<p><em>git reflog</em></p>
<p> 可以查看所有分支的所有操作记录（包括已经被删除的 commit 记录和 reset 的操作）</p>
<p><em>git show</em></p>
<p> 查看提交的详情</p>
<ul>
<li>1.查看最新的commit</li>
</ul>
<p><em>git show</em></p>
<ul>
<li>2.查看指定commit hashID的所有修改：</li>
</ul>
<p><em>git show &lt; commitId &gt;</em></p>
<ul>
<li>3.查看某次commit中具体某个文件的修改：</li>
</ul>
<p><em>git show &lt; commitId fileName &gt;</em></p>
<h2 id="Commit-message-的格式"><a href="#Commit-message-的格式" class="headerlink" title="Commit message 的格式"></a>Commit message 的格式</h2><h3 id="传统方式"><a href="#传统方式" class="headerlink" title="传统方式"></a>传统方式</h3><p>每次提交，Commit message 都包括三个部分：Header，Body 和 Footer。Header 是必需的，Body 和 Footer 可以省略。</p>
<p>（1）type</p>
<p>type用于说明 commit 的类别，只允许使用下面7个标识。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">feat：新功能（feature）</span><br><span class="line">fix：修补bug</span><br><span class="line">docs：文档（documentation）</span><br><span class="line">style： 格式（不影响代码运行的变动）</span><br><span class="line">refactor：重构（即不是新增功能，也不是修改bug的代码变动）</span><br><span class="line">test：增加测试</span><br><span class="line">chore：构建过程或辅助工具的变动</span><br></pre></td></tr></table></figure>
<p>（2）scope</p>
<p>scope用于说明 commit 影响的范围，比如数据层、控制层、视图层等等，视项目不同而不同。</p>
<p>（3）subject</p>
<p>subject是 commit 目的的简短描述，不超过50个字符。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">以动词开头，使用第一人称现在时，比如change，而不是changed或changes</span><br><span class="line">第一个字母小写</span><br><span class="line">结尾不加句号（.）</span><br></pre></td></tr></table></figure>
<h3 id="blingbling-emoji"><a href="#blingbling-emoji" class="headerlink" title="blingbling emoji"></a>blingbling emoji</h3><p>To use gitmojis from your command line install gitmoji-cli. A gitmoji interactive client for using emojis on commit messages.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i -g gitmoji-cli</span><br></pre></td></tr></table></figure>
<p><em>常用<a class="link"   href="https://gitmoji.carloscuesta.me/" >emoji<i class="fas fa-external-link-alt"></i></a></em></p>
<p>:memo: :pencil:Add or update documentation.<br>:pencil2:Fix typos.<br>:bug:Fix a bug.<br>:rocket:Deploy stuff.<br>:sparkles:Introduce new features.<br>:tada:Begin a project.<br>参考：<br><a class="link"   href="https://ruby-china.org/topics/15737" >Git 写出好的 commit message<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.htm" >Commit message 和 Change log 编写指南<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://zhuanlan.zhihu.com/p/29764863" >git commit 时使用 Emoji <i class="fas fa-external-link-alt"></i></a></p>
<h1 id="git-其他"><a href="#git-其他" class="headerlink" title="git 其他"></a>git 其他</h1><h2 id="git-add-与-git-add-的区别"><a href="#git-add-与-git-add-的区别" class="headerlink" title="git add . 与 git add * 的区别"></a>git add . 与 git add * 的区别</h2><ul>
<li>1<br>git add . 按.gitignore规则全部提交。不会提示.gitignore<br>git add * 与add .  不一样的在于会提示已被忽略的内容。</li>
</ul>
<p><img src="https://i.loli.net/2020/12/31/2qewiGLZths853p.png" alt="image.png"></p>
<ul>
<li>2<br>git add .默认添加. 开头的文件  例如.gitignore   git add * 忽略. 开头的文件</li>
</ul>
<h2 id="git中出现-gt-这个符号怎么退出？"><a href="#git中出现-gt-这个符号怎么退出？" class="headerlink" title="git中出现 &gt; 这个符号怎么退出？"></a>git中出现 &gt; 这个符号怎么退出？</h2><p>ctrl + d 即可退出。</p>
<p>这个表示没有输入完成，输入没有闭合。比如，只输入了一边的双引号或单引号。</p>
<h2 id="如何重置本项目用户信息："><a href="#如何重置本项目用户信息：" class="headerlink" title="如何重置本项目用户信息："></a>如何重置本项目用户信息：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config user.name &#39;your name&#39;</span><br><span class="line">git config user.email xx@email.com</span><br></pre></td></tr></table></figure>
<h2 id="git为本地分支设置对应的远程分支"><a href="#git为本地分支设置对应的远程分支" class="headerlink" title="git为本地分支设置对应的远程分支"></a>git为本地分支设置对应的远程分支</h2><p>当运行git pull时，如果本地分支没有绑定远程分支，将无法正常pull。<br>运行命令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch --set-upstream-to&#x3D;origin&#x2F;branchName</span><br></pre></td></tr></table></figure>
<h2 id="Git中用vim打开、修改、保存文件"><a href="#Git中用vim打开、修改、保存文件" class="headerlink" title="Git中用vim打开、修改、保存文件"></a>Git中用vim打开、修改、保存文件</h2><p>一、vim 有两种工作模式：<br>1.命令模式：接受、执行 vim操作命令的模式，打开文件后的默认模式； </p>
<p>2.编辑模式：对打开的文件内容进行 增、删、改 操作的模式；</p>
<p>3.在编辑模式下按下ESC键，回退到命令模式；在命令模式下按i，进入编辑模式</p>
<p>二、创建、打开文件：</p>
<p>1.输入 touch 文件名 ，可创建文件。</p>
<p>2.使用 vim 加文件路径（或文件名）的模式打开文件，如果文件存在则打开现有文件，如果文件不存在则新建文件。 </p>
<p>3.键盘输入字母i进入插入编辑模式。</p>
<p>三、保存文件： </p>
<p>1.在编辑模式下编辑文件 </p>
<p>2.按下ESC键，退出编辑模式，切换到命令模式。 </p>
<p>3.在命令模式下键入”ZZ”或者”:wq”保存修改并且退出 vim。 </p>
<p>4.如果只想保存文件，则键入”:w”，回车后底行会提示写入操作结果，并保持停留在命令模式。</p>
<p>四、放弃所有文件修改：<br>1.放弃所有文件修改：按下ESC键进入命令模式，键入”:q!”回车后放弃修改并退出vim。 </p>
<p>2.放弃所有文件修改，但不退出 vi，即回退到文件打开后最后一次保存操作的状态，继续进行文件操作：按下ESC键进入命令模式，键入”:e!”，回车后回到命令模式。</p>
<p>五、查看文件内容：</p>
<p>在git窗口，输入命令：cat 文件名</p>
<p> 六、创建文件夹</p>
<p>在git窗口，输入命令：touch 文件夹名</p>
<h2 id="使用Git上传项目时需要输入用户名和密码"><a href="#使用Git上传项目时需要输入用户名和密码" class="headerlink" title="使用Git上传项目时需要输入用户名和密码"></a>使用Git上传项目时需要输入用户名和密码</h2><h3 id="小登陆框"><a href="#小登陆框" class="headerlink" title="小登陆框"></a>小登陆框</h3><p>这里简述一下主要步骤：</p>
<p>step1.将上传代码的方式从 https 改成 ssh<br><img src="https://i.loli.net/2020/11/21/f6q1YtxQbuHjTUP.png" width = "30%" hight="30%" /><br>使用命令：<code>git remote set-url origin git@github.com:LawsonAbs/luogu.git</code> 后面的用户和项目名需要根据你自己的情况而改变。</p>
<p>step2.在自己本地生成ssh公钥并写在github中指定项目的key中<br><code>ssh-keygen -rsa -C &quot;LawsonAbs&quot;</code> 生成LawsonAbs这个用户的公钥。</p>
<p>step3.执行命令 <code>git push -u origin master</code></p>
<h3 id="小登录"><a href="#小登录" class="headerlink" title="小登录"></a>小登录</h3><h2 id="Git自动push-pull"><a href="#Git自动push-pull" class="headerlink" title="Git自动push/pull"></a>Git自动push/pull</h2><h3 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h3><p>bat脚本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">@echo off</span><br><span class="line">e:</span><br><span class="line">cd C:\Users\Lei Yu\OneDrive - bupt.edu.cn\Document\MarkDownNote</span><br><span class="line">git config --global credential.helper store</span><br><span class="line">git pull</span><br></pre></td></tr></table></figure>
<p>将该脚本放到git仓库的根目录中</p>
<img src="https://i.loli.net/2020/12/30/I5aPugKB8JsHyN7.png" alt="image-20201214140659729.png" style="zoom:50%;" />

<img src="https://i.loli.net/2020/12/30/MEGXt1kxI9jyzVH.png" alt="image-20201214140108699.png" style="zoom:50%;" />

<p>参考：<a class="link"   href="https://blog.csdn.net/yougou_sully/article/details/106114253" >https://blog.csdn.net/yougou_sully/article/details/106114253<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="Mac"><a href="#Mac" class="headerlink" title="Mac"></a>Mac</h3><p>利用<a class="link"   href="https://zh.wikipedia.org/wiki/Cron" >crontab<i class="fas fa-external-link-alt"></i></a>编写定时脚本，自动同步（可以在macOS和Linux下运行）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">crontab -e</span><br></pre></td></tr></table></figure>
<p>输入下列定时任务（每15分钟同步一次）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">*/15 * * * * <span class="built_in">cd</span> /Users/yourname/Markdown;git add .;git commit -m <span class="string">&quot;AutoSave&quot;</span>;git push origin master</span><br></pre></td></tr></table></figure>
<p>保存即可，可以用下列命令检验定时脚本是否设置成功。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">crontab -l</span><br></pre></td></tr></table></figure>
<h2 id="git-fetch-amp-pull详解"><a href="#git-fetch-amp-pull详解" class="headerlink" title="git fetch &amp; pull详解"></a><a class="link"   href="https://www.cnblogs.com/runnerjack/p/9342362.html" >git fetch &amp; pull详解<i class="fas fa-external-link-alt"></i></a></h2><p><strong>1、 简单概括</strong></p>
<p>先用一张图来理一下git fetch和git pull的概念：</p>
<img src="https://i.loli.net/2020/12/30/W5Gpohtq9JMXgSx.png" alt="image-20201216152342411.png" style="zoom:50%;" />

<p>可以简单的概括为：</p>
<p>git fetch是将远程主机的最新内容拉到本地，用户在检查了以后决定是否合并到工作本机分支中。</p>
<p>而git pull 则是将远程主机的最新内容拉下来后直接合并，即：git pull = git fetch + git merge，这样可能会产生冲突，需要手动解决。</p>
<p>下面我们来详细了解一下git fetch 和git pull 的用法。 </p>
<p><strong>2、分支的概念</strong></p>
<p>在介绍两种方法之前，我们需要先了解一下分支的概念： </p>
<p>分支是用来标记特定代码的提交，每一个分支通过SHA1sum值来标识，所以对分支的操作是轻量级的，你改变的仅仅是SHA1sum值。</p>
<p>如下图所示，当前有2个分支，A,C,E属于master分支，而A,B，D,F属于dev分支。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A----C----E（master）</span><br><span class="line"> \</span><br><span class="line">  B---D---F(dev)</span><br></pre></td></tr></table></figure>
<p>它们的head指针分别指向E和F，对上述做如下操作：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout master  //选择or切换到master分支</span><br><span class="line"> git merge dev     //将dev分支合并到当前分支(master)中</span><br></pre></td></tr></table></figure>
<p>合并完成后：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A---C---E---G(master)</span><br><span class="line"> \       \</span><br><span class="line">  B---D---F（dev）</span><br></pre></td></tr></table></figure>
<p>现在ABCDEG属于master，G是一次合并后的结果，是将E和Ｆ的代码合并后的结果，可能会出现冲突。而ABDF依然属于dev分支。可以继续在dev的分支上进行开发:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A---C---E---G---H(master)</span><br><span class="line"> \       \</span><br><span class="line">  B---D---F---I（dev）</span><br></pre></td></tr></table></figure>
<p>分支（branch）的基本操作：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch //查看本地所有分支 </span><br><span class="line"></span><br><span class="line">git branch -r //查看远程所有分支</span><br><span class="line"></span><br><span class="line">git branch -a //查看本地和远程的所有分支</span><br><span class="line"></span><br><span class="line">git branch &lt;branchname&gt; //新建分支</span><br><span class="line"></span><br><span class="line">git branch -d &lt;branchname&gt; //删除本地分支</span><br><span class="line"></span><br><span class="line">git branch -d -r &lt;branchname&gt; //删除远程分支，删除后还需推送到服务器</span><br><span class="line"> git push origin:&lt;branchname&gt; //删除后推送至服务器</span><br><span class="line"></span><br><span class="line">git branch -m &lt;oldbranch&gt; &lt;newbranch&gt; //重命名本地分支</span><br><span class="line"> /**</span><br><span class="line"> *重命名远程分支：</span><br><span class="line"> *1、删除远程待修改分支</span><br><span class="line"> *2、push本地新分支到远程服务器</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">//git中一些选项解释:</span><br><span class="line"></span><br><span class="line">-d</span><br><span class="line"> --delete：删除</span><br><span class="line"></span><br><span class="line">-D</span><br><span class="line"> --delete --force的快捷键</span><br><span class="line"></span><br><span class="line">-f</span><br><span class="line"> --force：强制</span><br><span class="line"></span><br><span class="line">-m</span><br><span class="line"> --move：移动或重命名</span><br><span class="line"></span><br><span class="line">-M</span><br><span class="line"> --move --force的快捷键</span><br><span class="line"></span><br><span class="line">-r</span><br><span class="line"> --remote：远程</span><br><span class="line"></span><br><span class="line">-a</span><br><span class="line"> --all：所有</span><br></pre></td></tr></table></figure>
<p><strong>3、git fetch</strong> <strong>用法</strong></p>
<p>git fetch 命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git fetch &lt;远程主机名&gt; //这个命令将某个远程主机的更新全部取回本地</span><br></pre></td></tr></table></figure>
<p>如果只想取回特定分支的更新，可以指定分支名：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git fetch &lt;远程主机名&gt; &lt;分支名&gt; //注意之间有空格</span><br></pre></td></tr></table></figure>
<p>最常见的命令如取回origin 主机的master 分支：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git fetch origin master</span><br></pre></td></tr></table></figure>
<p>取回更新后，会返回一个FETCH_HEAD ，指的是某个branch在服务器上的最新状态，我们可以在本地通过它查看刚取回的更新信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> -p FETCH_HEAD</span><br></pre></td></tr></table></figure>
<p>如图： </p>
<img src="https://i.loli.net/2020/12/30/u6sKZoTQqXzhP1D.png" alt="clip_image002.png" style="zoom: 67%;" />

<p>可以看到返回的信息包括更新的文件名，更新的作者和时间，以及更新的代码（19行红色[删除]和绿色[新增]部分）。</p>
<p>我们可以通过这些信息来判断是否产生冲突，以确定是否将更新merge到当前分支。 </p>
<p><strong>4、git pull</strong> <strong>用法</strong></p>
<p>前面提到，git pull 的过程可以理解为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git fetch origin master //从远程主机的master分支拉取最新内容 </span><br><span class="line">git merge FETCH_HEAD   //将拉取下来的最新内容合并到当前所在的分支中</span><br></pre></td></tr></table></figure>
<p>即将远程主机的某个分支的更新取回，并与本地指定的分支合并，完整格式可表示为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</span><br></pre></td></tr></table></figure>
<p>如果远程分支是与当前分支合并，则冒号后面的部分可以省略：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git pull origin next</span><br></pre></td></tr></table></figure>
<h2 id="删除最后一次远程提交"><a href="#删除最后一次远程提交" class="headerlink" title="删除最后一次远程提交"></a>删除最后一次远程提交</h2><p><em>方式一：使用revert</em></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git revert HEAD</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push origin master</span></span><br></pre></td></tr></table></figure>
<p><em>方式二：使用reset</em></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git reset --hard HEAD^</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push origin master -f</span></span><br></pre></td></tr></table></figure>
<p><em>二者区别：</em></p>
<ul>
<li><strong>revert</strong> 是放弃指定提交的修改，但是会生成一次新的提交，需要填写提交注释，以前的历史记录都在；</li>
<li><strong>reset</strong> 是指将HEAD指针指到指定提交，历史记录中不会出现放弃的提交记录。</li>
</ul>
<h1 id="git-报错"><a href="#git-报错" class="headerlink" title="git 报错"></a>git 报错</h1><h2 id="fatal-This-operation-must-be-run-in-a-work-tree"><a href="#fatal-This-operation-must-be-run-in-a-work-tree" class="headerlink" title="fatal: This operation must be run in a work tree"></a>fatal: This operation must be run in a work tree</h2><p>可能原因： 1.路径不正确<br>          2.git仓库没有正确创建</p>
<h2 id="warning-LF-will-be-replaced-by-CRLF-in-The-file-will-have-its-original-line-endings-in-y"><a href="#warning-LF-will-be-replaced-by-CRLF-in-The-file-will-have-its-original-line-endings-in-y" class="headerlink" title="warning: LF will be replaced by CRLF in ****. The file will have its original line endings in y"></a>warning: LF will be replaced by CRLF in ****. The file will have its original line endings in y</h2><p>警告原因：可能是你的项目使用了GitHub的开源项目，这个开源项目上传的环境（Linux）和你本次上传GitHub仓库的环境（Windows）不同<br>例如：本机上传的环境是win10    ，而在你本机项目中引用的GitHub项目上传环境是Linux</p>
<p>windows中的换行符为 CRLF，而在Linux下的换行符为LF</p>
<p>就会产生如上换行符不同的警告<br>但是这个错误可以直接忽略，对项目影响不大，我觉着如果以后项目在其他环境上运行的话，还可以通过这个方法改变换行符，是项目在其他环境中正常运行！</p>
<h2 id="Automatic-merge-failed-fix-conflicts-and-then-commit-the-result"><a href="#Automatic-merge-failed-fix-conflicts-and-then-commit-the-result" class="headerlink" title="Automatic merge failed; fix conflicts and then commit the result."></a>Automatic merge failed; fix conflicts and then commit the result.</h2><p>自动合并失败；修改冲突然后提交修改后的结果。<br>&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</p>
<pre><code>     你写的代码</code></pre>
<p>===============</p>
<pre><code>      别人写的代码</code></pre>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>sdhqd128dqwenasjdq</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<h2 id="Another-git-process-seems-to-be-running-in-this-repository"><a href="#Another-git-process-seems-to-be-running-in-this-repository" class="headerlink" title="Another git process seems to be running in this repository"></a>Another git process seems to be running in this repository</h2><p>windows对于进程的同步互斥管理，是有资源上锁机制的。猜测这里肯定是有进程对某资源进行了加锁，但是由于进程突然崩溃，未来得及解锁，导致其他进程访问不了。<br>进入工作区目录下的隐藏文件.git，其中的index.lock文件删除掉，然后重新打开git bash进程，问题解决。</p>
<h2 id="git-push错误failed-to-push-some-refs-to解决方法"><a href="#git-push错误failed-to-push-some-refs-to解决方法" class="headerlink" title="git push错误failed to push some refs to解决方法"></a>git push错误failed to push some refs to解决方法</h2><p><strong>原因</strong></p>
<p>当我们在git版本库中发现一个问题后，如你在git上对它进行了在线修改，但是没有对本地库进行同步（做到push之前，都先pull下代码，就可以保证本地库和远程库代码一致）。这个时候你再次commit，想把本地库提交到远程git库中，就会出现push失败问题。</p>
<blockquote>
<p>failed to push some refs to</p>
</blockquote>
<p><strong>解决</strong></p>
<p>方法：1</p>
<p>跟因就是远程库与本地库代码不一致导致的，我们只要把远程库同步到本地库即可，使用如下命令：</p>
<blockquote>
<p>git pull –rebase origin master</p>
</blockquote>
<p>指令意思就是把远程库中的跟新合并到本地库中（可能存在冲突需要解决），–rebase的作用是取消本地库中刚刚提交的commit，并把他们接到更新后的版本库中。</p>
<p>方法：2</p>
<p>或者使用如下命令，将commit的代码撤回，然后再git pull也行。</p>
<blockquote>
<p>git reset –soft HEAD^</p>
</blockquote>
<h2 id="refusing-to-merge-unrelated-histories"><a href="#refusing-to-merge-unrelated-histories" class="headerlink" title="refusing to merge unrelated histories"></a>refusing to merge unrelated histories</h2><p>I think you have commit in remote repository and when you pull this error happen.</p>
<p>use this command</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git pull origin master --allow-unrelated-histories</span><br><span class="line">git merge origin origin/master</span><br></pre></td></tr></table></figure>
<p>i suggest reading at <a class="link"   href="https://stackoverflow.com/questions/39761024/refusing-to-merge-unrelated-histories-failure-while-pulling-to-recovered-repos" >https://stackoverflow.com/questions/39761024/refusing-to-merge-unrelated-histories-failure-while-pulling-to-recovered-repos<i class="fas fa-external-link-alt"></i></a></p>
<p>This cannot be answered shortly.</p>
<p><strong>Warning</strong>: You <strong>should not</strong> use the <code>--allow-unrelated-histories</code> flag unless you know what unrelated history is and are sure you need it. The check was introduced just to prevent disasters when people merge unrelated projects by mistake.</p>
<p><em>As far as I understand</em>, in your case <strong>has happened the following</strong>:</p>
<p>You have cloned a project at some point <code>1</code>, and made some development to point <code>2</code>. Meanwhile, project has evolved to some point <code>3</code>.</p>
<p><img src="https://i.loli.net/2020/12/31/46K8hvcb2szfDei.png" alt="image.png"></p>
<p>Then you for some reason lost your local .git subdirectory - which contained all your history from <code>1</code> to <code>2</code>. You managed to restore the current state though.</p>
<p><img src="https://i.loli.net/2020/12/31/lHrdIohY27LnQuR.png" alt="image.png"></p>
<p>But now it does not have any history - it looks like the whole project has appeared out of nowhere. If you ask Git to merge them it will not be able to say where your changes are, so it can add them to remote project, as far as I understand it will just report massive add/add conflicts.</p>
<p><strong>You should</strong> now find back that commit <code>1</code> from the remote history where you have cloned the project (I assume you did not pull after that; if you did then you should instead look for the last commit you have pulled). Then you should modify your history so that is starts from that commit 1, and then Git will be able to merge correctly (with pull for example).</p>
<p>So, the steps (assuming you are now in your restored commit without history):</p>
<ul>
<li>estimate where is the commit <code>1</code> you have cloned from as some <code>1?</code>, based on commit time for example</li>
<li>run <code>git diff _1?_..HEAD</code>, and read carefully. Make sure that the difference contains only edits which you have made. If it contains more then you should have picked a bit wrong <code>1?</code> and need to adjust it and repeat this step</li>
<li>after you have found the commit <code>1</code>. You should make it your parent; do <code>git --reset --soft _1_</code>, and then <code>git commit</code>.</li>
</ul>
<p><img src="https://i.loli.net/2020/12/31/OY9r8AGXcPMBVUe.png" alt="image.png"></p>
<p>Now it looks like you have cloned from <code>1</code>, then made one commit with all your changes. Your intermediate history is lost anyway with your older <code>.git</code> directory, but now you can run your <code>git pull</code> - it will merge correctly.</p>
<h2 id="Mac上报错-fatal-Authentication-failed-for"><a href="#Mac上报错-fatal-Authentication-failed-for" class="headerlink" title="Mac上报错 fatal: Authentication failed for"></a>Mac上报错 fatal: Authentication failed for</h2><p>使用mac下载Azure DevOps项目时，使用git clone xxx 命令后出现需要输入密码，输入后显示报错。原因为mac连接azure项目有bug，官方给出解决方案：</p>
<p>1.终端依次输入</p>
<p>brew tap microsoft/git</p>
<p>brew install –cask git-credential-manager-core</p>
<p>brew upgrade git-credential-manager-core</p>
<p>2.重新输入命令git clone xxx 若跳出登陆窗口输入账户和密码，解决。</p>
<p>参考：<a class="link"   href="https://github.com/microsoft/Git-Credential-Manager-Core#download-and-install" >https://github.com/microsoft/Git-Credential-Manager-Core#download-and-install<i class="fas fa-external-link-alt"></i></a></p>
<h1 id="gitignore用法"><a href="#gitignore用法" class="headerlink" title=".gitignore用法"></a>.gitignore用法</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 忽略 .a 文件</span><br><span class="line">*.a</span><br><span class="line"># 但否定忽略 lib.a, 尽管已经在前面忽略了 .a 文件</span><br><span class="line">!lib.a</span><br><span class="line"># 仅在当前目录下忽略 TODO 文件， 但不包括子目录下的 subdir&#x2F;TODO</span><br><span class="line">&#x2F;TODO</span><br><span class="line"># 忽略 build&#x2F; 文件夹下的所有文件</span><br><span class="line">build&#x2F;</span><br><span class="line"># 忽略 doc&#x2F;notes.txt, 不包括 doc&#x2F;server&#x2F;arch.txt</span><br><span class="line">doc&#x2F;*.txt</span><br><span class="line"># 忽略所有的 .pdf 文件 在 doc&#x2F; directory 下的</span><br><span class="line">doc&#x2F;**&#x2F;*.pdf</span><br></pre></td></tr></table></figure>
<p><a class="link"   href="https://github.com/github/gitignore" >模板<i class="fas fa-external-link-alt"></i></a></p>
<h1 id="其他git命令"><a href="#其他git命令" class="headerlink" title="其他git命令"></a>其他git命令</h1><ol>
<li>修改最近的提交<br>git commit –amend<br>Copy</li>
</ol>
<p>-amend 参数允许追加修改至最后一次提交之后（比如忘记提交的文件），添加 -no-edit 参数将追加提交至最后一次提交之内并且不改变提交的备注信息。如果没有新的修改提交， -amend 参数将会重写最后一次提交的备注信息。</p>
<p>查看更多：git help commit</p>
<ol start="2">
<li>交互式选择部分修改<br>git add -p</li>
</ol>
<p>-p (或 -path) 会允许我们交互式的选择是否提交每一处改动，这样，每次提交就只包含一处修改，即 拆分我们的该次添加修改，每一处修改都有一个提交</p>
<p>查看更多: git help add</p>
<ol start="3">
<li>交互式的处理储藏中文件的每个部分<br>git stash -p<br>跟 git-add 有点类似，你可以使用 –patch 选项交互式地选择每个跟踪文件的要储藏的部分。</li>
</ol>
<p>通过  git help stash 命令了解更多。</p>
<ol start="4">
<li><p>储藏未跟踪的文件<br>git stash -u<br>默认情况下，储藏命令是不包括未跟踪的文件的。为了储藏未跟踪的文件你需要使用 -u 参数。 -a (—all) 参数会将未跟踪和忽略的文件一起储藏，通常情况下，这可能不是你需要的。</p>
</li>
<li><p>交互式地还原文件的选中部分<br>git checkout -p</p>
</li>
</ol>
<p>–patch 参数还可以用于有选择的丢弃每个跟踪文件的某些部分。我给这个命令起了个别名叫 git discard。</p>
<p>使用 git help checkout 了解更多。</p>
<ol start="6">
<li><p>切到上一个分支<br>git checkout -<br>该命令可以使你快速切换到之前签出的分支。一般来说 - 是上一个分支的别名。它可以跟别的命令一起使用。我将 checkout 简写成 co ，这样它就变成了  git co - 。</p>
</li>
<li><p>还原本地所有修改<br>git checkout .<br>在确定可以放弃所有本地修改的情况下可以使用  . 立即去完成。好的习惯是使用 checkout –patch 命令。</p>
</li>
<li><p>查看修改<br>git diff –staged<br>这个命令会显示已经暂存的文件和上次提交文件之前的差异，git diff 是显示还没有暂存起来的修改；当你使用 git add . 之后再使用 git diff 就会发现什么都没有。</p>
</li>
</ol>
<p>使用 git help diff 了解更多。</p>
<ol start="9">
<li>重命名本地分支<br>git branch -m old-name new-name<br>如果你想重命名当前所在的分支，可以将命令缩短为以下格式:</li>
</ol>
<p>git branch -m new-name<br>查看更多: git help branch</p>
<ol start="10">
<li>重命名远端分支<br>为了重命名远端分支，你一旦修改本地分支名称，就立即需要删除远端分支，再将重命名后的本地分支推送上去。</li>
</ol>
<p>git push origin :old-name<br>git push origin new-name<br>11. 一次性查看所有冲突文件<br>变基可能会导致冲突，这个命令将打开所有需要你处理的冲突文件。</p>
<p>git diff –name-only –diff-filter=U | uniq  | xargs $EDITOR<br>12. 有哪些改变？<br>git whatchanged –since=”2 weeks ago”<br>该命令将显示最近两周提交的简单日志，包括每次提交的介绍和修改的文件。下图是译者找的 demo：</p>
<ol start="13">
<li>从最近一次提交中删除文件<br>假设你提交了一个错误的文件。你可以通过组合 rm 和 commit –amend 命令从上次提交中快速删除它：</li>
</ol>
<p>git rm —-cached <file-to-remove><br>git commit —-amend<br>14. 查找分支<br>git branch –contains <commit><br>该命令将展示包含指定提交的所有分支。</p>
<ol start="15">
<li>本地储藏优化<br>git gc –prune=now –aggressive</li>
</ol>
]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>SDK接入问题</title>
    <url>/2021/01/07/AndroidSDK/</url>
    <content><![CDATA[<h2 id="1-1-Android-SDK-问题"><a href="#1-1-Android-SDK-问题" class="headerlink" title="1.1   Android SDK 问题"></a>1.1   Android SDK 问题</h2><h3 id="1-1-1-Android-SDK-及-NDK安装及路径问题"><a href="#1-1-1-Android-SDK-及-NDK安装及路径问题" class="headerlink" title="1.1.1   Android SDK 及 NDK安装及路径问题"></a>1.1.1   Android SDK 及 NDK安装及路径问题</h3><p>报错如下</p>
<p>![img](C:/Users/Lei Yu/OneDrive - bupt.edu.cn/Document/MarkDownImg/clip_image002.jpg)</p>
<p>解决方法</p>
<p>AndroidSDK与NDK路径需尽量短，否则会报无法识别路径错误，这是个大坑。</p>
<h3 id="1-1-2-AndroidSDK与发布版本匹配问题"><a href="#1-1-2-AndroidSDK与发布版本匹配问题" class="headerlink" title="1.1.2   AndroidSDK与发布版本匹配问题"></a>1.1.2   AndroidSDK与发布版本匹配问题</h3><p>报错如下</p>
<p>![img](C:/Users/Lei Yu/OneDrive - bupt.edu.cn/Document/MarkDownImg/clip_image004.jpg)</p>
<p>解决方法</p>
<p>首先需要将SDK与预发布版本相对应，一般情况下应该安装不同版本的SDK。之后需要在SDK路径下的tools/bin 执行命令./sdkmanager.bat –licenses</p>
]]></content>
      <tags>
        <tag>SDK</tag>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2021/03/10/Golang/</url>
    <content><![CDATA[<h1 id="Go语言结构"><a href="#Go语言结构" class="headerlink" title="Go语言结构"></a>Go语言结构</h1><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main<span class="comment">//声明了 main.go 所在的包，Go 语言中使用包来组织代码。一般一个文件夹即一个包，包内可以暴露类型或方法供其他包使用。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span><span class="comment">//fmt 是 Go 语言的一个标准库/包，用来处理标准输入输出。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;<span class="comment">//main 函数是整个程序的入口，main 函数所在的包名也必须为 main。</span></span><br><span class="line"></span><br><span class="line">  fmt.Println(<span class="string">&quot;Hello go&quot;</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h2><p>Go 语言是静态类型的,变量声明时必须明确变量的类型</p>
<p>Go 语言与其他语言显著不同的一个地方在于，Go 语言的类型在变量后面</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span> =<span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">byte</span> =<span class="string">&#x27;g&#x27;</span></span><br><span class="line"><span class="keyword">var</span> c <span class="keyword">int8</span> = <span class="number">2</span></span><br><span class="line"><span class="keyword">var</span> d <span class="keyword">float32</span> =<span class="number">12.1</span></span><br><span class="line"><span class="keyword">var</span> e <span class="keyword">bool</span> = <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h2 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h2><p>变量赋值有多种方法</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> b=<span class="number">1</span><span class="comment">//自动确定类型</span></span><br><span class="line">c:=<span class="number">3</span></span><br><span class="line">d:=<span class="string">&quot;this is go&quot;</span><span class="comment">//简写方式</span></span><br></pre></td></tr></table></figure>
<p>空值：nil</p>
<p>整型类型： int(取决于操作系统), int8, int16, int32, int64, uint8, uint16, …</p>
<p>浮点数类型：float32, float64</p>
<p>字节类型：byte (等价于uint8)</p>
<p>字符串类型：string</p>
<p>布尔值类型：boolean，(true 或 false)</p>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">str1 := <span class="string">&quot;Golang&quot;</span></span><br><span class="line">str2 := <span class="string">&quot;Go语言&quot;</span></span><br><span class="line">fmt.Println(reflect.TypeOf(str2[<span class="number">2</span>]).Kind()) <span class="comment">// uint8   reflect.TypeOf().Kind() 可以知道某个变量的类型，我们可以看到，字符串是以 byte 数组形                                                        式保存的，类型是 uint8，占1个 byte，打印时需要用 string 进行类型转换，否则打印的是编码                                                        值。</span></span><br><span class="line">fmt.Println(str1[<span class="number">2</span>], <span class="keyword">string</span>(str1[<span class="number">2</span>]))       <span class="comment">// 108 l</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%d %c\n&quot;</span>, str2[<span class="number">2</span>], str2[<span class="number">2</span>])     <span class="comment">// 232 è   因为字符串是以 byte 数组的形式存储的，所以，str2[2] 的值并不等于语。str2 的长度                                                              len(str2) 也不是 4，而是 8（ Go 占 2 byte，语言占 6 byte）。</span></span><br><span class="line">fmt.Println(<span class="string">&quot;len(str2)：&quot;</span>, <span class="built_in">len</span>(str2))       <span class="comment">// len(str2)： 8</span></span><br></pre></td></tr></table></figure>
<p>正确的处理方法</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">str2 := <span class="string">&quot;Go语言&quot;</span></span><br><span class="line"></span><br><span class="line">runeArry:=[]<span class="keyword">rune</span>(str2)</span><br><span class="line">fmt.Println(reflect.TypeOf(runeArry[<span class="number">2</span>]).Kind())<span class="comment">//int32</span></span><br><span class="line">fmt.Println(runeArry[<span class="number">2</span>],<span class="keyword">string</span>(runeArry[<span class="number">2</span>]))<span class="comment">//35821 语</span></span><br><span class="line">fmt.Println(<span class="string">&quot;len(runeArry):&quot;</span>,<span class="built_in">len</span>(runeArry))<span class="comment">//len(runeArry): 4</span></span><br><span class="line"><span class="comment">//转换成 []rune 类型后，字符串中的每个字符，无论占多少个字节都用 int32 来表示，因而可以正确处理中文。</span></span><br></pre></td></tr></table></figure>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><h4 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 [<span class="number">5</span>]<span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> arr2 [<span class="number">2</span>][<span class="number">2</span>]<span class="keyword">int</span></span><br><span class="line">arr3:=[<span class="number">3</span>]<span class="keyword">string</span>&#123;<span class="string">&quot;this&quot;</span>,<span class="string">&quot;is&quot;</span>,<span class="string">&quot;go&quot;</span>&#125;</span><br><span class="line"><span class="comment">//var arr4 []int</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line">	arr1[i]+=<span class="number">10</span></span><br><span class="line">	arr2[i][<span class="number">0</span>]+=<span class="number">10</span></span><br><span class="line">	<span class="comment">//arr4[i]+=10</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(arr1,arr2,arr3)<span class="comment">//[10 10 0 0 0] [[10 0] [10 0]] [this is go]</span></span><br></pre></td></tr></table></figure>
<p>go 的数组可直接输出不需遍历</p>
<h4 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h4><p>数组的长度不能改变，如果想拼接2个数组，或是获取子数组，需要使用切片。切片是数组的抽象。 切片使用数组作为底层结构。<strong>切片包含三个组件：容量，长度和指向底层数组的指针,切片可以随时进行扩展</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">slice1:=<span class="built_in">make</span>([]<span class="keyword">float32</span>,<span class="number">0</span>)<span class="comment">//长度为0的切片</span></span><br><span class="line">slice2:=<span class="built_in">make</span>([]<span class="keyword">float32</span>,<span class="number">3</span>,<span class="number">5</span>)<span class="comment">//长度为3容量为5的切片</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(slice1),<span class="built_in">cap</span>(slice2))<span class="comment">//0 5</span></span><br></pre></td></tr></table></figure>
<p>添加元素，切片容量可以根据需要自动扩展</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">sub1:=slice1[<span class="number">3</span>:]<span class="comment">//[1 2 3 4]</span></span><br><span class="line">sub2:=slice1[:<span class="number">3</span>]<span class="comment">//[0 0 0]</span></span><br><span class="line">sub3:=slice1[<span class="number">1</span>:<span class="number">4</span>]<span class="comment">//[0 0 1]</span></span><br><span class="line">combined:=<span class="built_in">append</span>(sub1,sub2...)<span class="comment">//[1 2 3 4 0 0 0]</span></span><br><span class="line">fmt.Println(sub1,sub2,sub3,combined)</span><br></pre></td></tr></table></figure>
<ul>
<li>声明切片时可以为切片设置容量大小，为切片预分配空间。在实际使用的过程中，如果容量不够，切片容量会自动扩展。</li>
<li><code>sub2...</code> 是切片解构的写法，将切片解构为 N 个独立的元素。*???????????*</li>
</ul>
<h1 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h1><p>fmt.println</p>
<p>l是L的小写，不是大写的i!!! 这个坑差点劝退我</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2021/03/10/MarkDownTech/</url>
    <content><![CDATA[<h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><p><strong>加粗文字</strong></p>
<h1 id="斜体"><a href="#斜体" class="headerlink" title="斜体"></a><em>斜体</em></h1><p><em>这样也是斜体</em></p>
<h1 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a><u>下划线</u></h1><h1 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a><del>删除线</del></h1><hr>
<h1 id="分隔符"><a href="#分隔符" class="headerlink" title="分隔符"></a>分隔符</h1><hr>
<h1 id="高亮"><a href="#高亮" class="headerlink" title="高亮"></a><code>高亮</code></h1><h1 id="textcolor-red-更改字体颜色"><a href="#textcolor-red-更改字体颜色" class="headerlink" title="$\textcolor{red}{更改字体颜色} $"></a>$\textcolor{red}{更改字体颜色} $</h1><p>方法一</p>
<p><span style="color:文字颜色;background:背景颜色;font-size:文字大小;font-family:字体;">你要改色的文字</span></p>
<p><span style="color:red;font-family:字体;">例如</span></p>
<p><span style="color:blue;background:yellow;font-size:文字大小;font-family:字体;">你要改色的文字</span></p>
<p>方法二</p>
<ol>
<li>$\textcolor{GreenYellow}{GreenYellow} $</li>
<li>$\textcolor{Yellow}{Yellow}$</li>
<li>$\textcolor{Goldenrod}{Goldenrod} $</li>
<li>$\textcolor{Dandelion}{Dandelion}$</li>
<li>$\textcolor{Apricot}{Apricot} $</li>
<li>$\textcolor{Peach}{Peach}$</li>
<li>$\textcolor{Melon}{Melon} $</li>
<li>$\textcolor{YellowOrange}{YellowOrange}$</li>
<li>$\textcolor{Orange}{Orange} $</li>
<li>$\textcolor{BurntOrange}{BurntOrange}$</li>
<li>$\textcolor{Bittersweet}{Bittersweet}$</li>
<li>$\textcolor{RedOrange}{RedOrange} $</li>
<li>$\textcolor{Mahogany}{Mahogany}$</li>
<li>$\textcolor{Maroon}{Maroon} $</li>
<li>$\textcolor{BrickRed}{BrickRed}$</li>
<li>$\textcolor{Red}{Red} $</li>
<li>$\textcolor{OrangeRed}{OrangeRed}$</li>
<li>$\textcolor{RubineRed}{RubineRed}$</li>
<li>$\textcolor{WildStrawberry}{WildStrawberry}$</li>
<li>$\textcolor{Salmon}{Salmon}$</li>
<li>$\textcolor{CarnationPink}{CarnationPink}$</li>
<li>$\textcolor{Magenta}{Magenta} $</li>
<li>$\textcolor{VioletRed}{VioletRed}$</li>
<li>$\textcolor{Rhodamine}{Rhodamine} $</li>
<li>$\textcolor{Mulberry}{Mulberry}$</li>
<li>$\textcolor{RedViolet}{RedViolet} $</li>
<li>$\textcolor{Fuchsia}{Fuchsia}$</li>
<li>$\textcolor{Lavender}{Lavender} $</li>
<li>$\textcolor{Thistle}{Thistle}$</li>
<li>$\textcolor{Orchid}{Orchid} $</li>
<li>$\textcolor{DarkOrchid}{DarkOrchid}$</li>
<li>$\textcolor{Purple}{Purple} $</li>
<li>$\textcolor{Plum}{Plum}$</li>
<li>$\textcolor{Violet}{Violet} $</li>
<li>$\textcolor{RoyalPurple}{RoyalPurple}$</li>
<li>$\textcolor{BlueViolet}{BlueViolet}$</li>
<li>$\textcolor{Periwinkle}{Periwinkle}$</li>
<li>$\textcolor{CadetBlue}{CadetBlue}$</li>
<li>$\textcolor{CornflowerBlue}{CornflowerBlue}$</li>
<li>$\textcolor{MidnightBlue}{MidnightBlue}$</li>
<li>$\textcolor{NavyBlue}{NavyBlue} $</li>
<li>$\textcolor{RoyalBlue}{RoyalBlue}$</li>
<li>$\textcolor{Blue}{Blue} $</li>
<li>$\textcolor{Cerulean}{Cerulean}$</li>
<li>$\textcolor{Cyan}{Cyan} $</li>
<li>$\textcolor{ProcessBlue}{ProcessBlue}$</li>
<li>$\textcolor{SkyBlue}{SkyBlue} $</li>
<li>$\textcolor{Turquoise}{Turquoise}$</li>
<li>$\textcolor{TealBlue}{TealBlue} $</li>
<li>$\textcolor{Aquamarine}{Aquamarine}$</li>
<li>$\textcolor{BlueGreen}{BlueGreen} $</li>
<li>$\textcolor{Emerald}{Emerald}$</li>
<li>$\textcolor{JungleGreen}{JungleGreen}$</li>
<li>$\textcolor{SeaGreen}{SeaGreen} $</li>
<li>$\textcolor{Green}{Green}$</li>
<li>$\textcolor{ForestGreen}{ForestGreen}$</li>
<li>$\textcolor{PineGreen}{PineGreen} $</li>
<li>$\textcolor{LimeGreen}{LimeGreen}$</li>
<li>$\textcolor{YellowGreen}{YellowGreen}$</li>
<li>$\textcolor{SpringGreen}{SpringGreen}$</li>
<li>$\textcolor{OliveGreen}{OliveGreen}$</li>
<li>$\textcolor{RawSienna}{RawSienna} $</li>
<li>$\textcolor{Sepia}{Sepia}$</li>
<li>$\textcolor{Brown}{Brown} $</li>
<li>$\textcolor{Tan}{Tan}$</li>
<li>$\textcolor{Gray}{Gray} $</li>
<li>$\textcolor{Black}{Black}$</li>
</ol>
<h1 id="引用文本"><a href="#引用文本" class="headerlink" title="引用文本"></a>引用文本</h1><blockquote>
<p>引用文本<br>…</p>
</blockquote>
<h1 id="数字列表"><a href="#数字列表" class="headerlink" title="数字列表"></a>数字列表</h1><ol>
<li>数字列表</li>
<li>符号列表</li>
</ol>
<ul>
<li>vscode 行！</li>
</ul>
<ul>
<li>这个也行</li>
</ul>
<h1 id="添加代办事项"><a href="#添加代办事项" class="headerlink" title="添加代办事项"></a>添加代办事项</h1><ul>
<li><input disabled="" type="checkbox"> 记笔记</li>
<li><input disabled="" type="checkbox"> 坚持记笔记</li>
</ul>
<h1 id="插入链接"><a href="#插入链接" class="headerlink" title="插入链接"></a>插入链接</h1><p><a href="www.google.com">google</a><br>链接格式<br><a href="https://travis-ci.org/joemccann/dillinger"><img src="https://travis-ci.org/joemccann/dillinger.svg?branch=master" alt="Build Status"></a></p>
<h1 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h1><p><img src="https://www.yinxiang.com/blog/wp-content/uploads/2018/07/%E5%94%AE%E7%A5%A8%E5%BE%AE%E4%BF%A1%E5%B0%81%E9%9D%A22.png" alt="image"></p>
<img src="https://www.yinxiang.com/blog/wp-content/uploads/2018/07/%E5%94%AE%E7%A5%A8%E5%BE%AE%E4%BF%A1%E5%B0%81%E9%9D%A22.png" width = "50%" />

<p><u>可通过以下参数控制图片大小<br>@w=300<br>@h=150<br>@w=200h=100<br>@h=100w=200</u></p>
<h1 id="插入表格"><a href="#插入表格" class="headerlink" title="插入表格"></a>插入表格</h1><table>
<thead>
<tr>
<th>帐户类型</th>
<th>免费帐户</th>
<th>标准帐户</th>
<th>高级帐户</th>
</tr>
</thead>
<tbody><tr>
<td>帐户流量</td>
<td>60M</td>
<td>1GB</td>
<td>10GB</td>
</tr>
<tr>
<td>设备数目</td>
<td>2台</td>
<td>无限制</td>
<td>无限制</td>
</tr>
<tr>
<td>当前价格</td>
<td>免费</td>
<td>￥8.17/月</td>
<td>￥12.33/月</td>
</tr>
</tbody></table>
<h1 id="插入代码"><a href="#插入代码" class="headerlink" title="插入代码"></a>插入代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#标注语言类型即可将显示格式转为对应语言</span></span><br><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">line = <span class="string">&quot;Cats are smarter than dogs&quot;</span></span><br><span class="line"></span><br><span class="line">matchObj = re.match( <span class="string">r&#x27;(.*) are (.*?) .*&#x27;</span>, line, re.M|re.I)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> matchObj:</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;matchObj.group() : &quot;</span>, matchObj.group()</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;matchObj.group(1) : &quot;</span>, matchObj.group(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;matchObj.group(2) : &quot;</span>, matchObj.group(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;No match!!&quot;</span></span><br></pre></td></tr></table></figure>

<h1 id="添加数学公式"><a href="#添加数学公式" class="headerlink" title="添加数学公式"></a>添加数学公式</h1><p>具体详见<a class="link"   href="https://katex.org/docs/supported.html" >katex<i class="fas fa-external-link-alt"></i></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">e^&#123;i\pi&#125; + 1 &#x3D; 0</span><br></pre></td></tr></table></figure>

<h1 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">graph TD</span><br><span class="line">A[模块A] --&gt;|A1| B(模块B)</span><br><span class="line">B --&gt; C&#123;判断条件C&#125;</span><br><span class="line">C --&gt;|条件C1| D[模块D]</span><br><span class="line">C --&gt;|条件C2| E[模块E]</span><br><span class="line">C --&gt;|条件C3| F[模块F]</span><br></pre></td></tr></table></figure>
<h1 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">A-&gt;&gt;B: 是否已收到消息？</span><br><span class="line">B--&gt;&gt;A: 已收到消息</span><br></pre></td></tr></table></figure>
<h1 id="甘特图"><a href="#甘特图" class="headerlink" title="甘特图"></a>甘特图</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gantt</span><br><span class="line">title 甘特图</span><br><span class="line">dateFormat YYYY-MM-DD</span><br><span class="line">section 项目A</span><br><span class="line">任务1 :a1, 2018-06-06, 30d</span><br><span class="line">任务2 :after a1 , 20d</span><br><span class="line">section 项目B</span><br><span class="line">任务3 :2018-06-12 , 12d</span><br><span class="line">任务4 : 24d</span><br></pre></td></tr></table></figure>
<h1 id="设置目录"><a href="#设置目录" class="headerlink" title="设置目录"></a>设置目录</h1><p>之后可以自动根据设置的分级标题来自动生成目录。<br>[TOC]</p>
<h1 id="隐藏文字-注释"><a href="#隐藏文字-注释" class="headerlink" title="隐藏文字/注释"></a>隐藏文字/注释</h1><p><a href="%E8%BF%99%E9%87%8C%E5%B0%B1%E7%9C%8B%E4%B8%8D%E5%88%B0%E4%BA%86,%E9%9C%80%E8%A6%81%E4%B8%8A%E9%9D%A2%E7%9A%84%E8%BF%99%E4%B8%89%E8%A1%8C%E6%89%8D%E8%A1%8C,%E4%BD%86%E6%98%AF%E4%B8%8D%E8%83%BD%E5%8A%A0%E7%A9%BA%E6%A0%BC">^_^</a>:<br>    commentted-out contents<br>    should be shift to right by four spaces (<code>&gt;&gt;</code>).</p>
<p><a href="%E8%BF%99%E4%B9%9F%E6%98%AF%E4%B8%80%E7%A7%8D%E6%96%B9%E6%B3%95"></a></p>
<p>但此处推荐一种不用隐藏的<a href="#%E6%B3%A8%E9%87%8A%E6%96%B9%E6%B3%95">注释方法</a>使用锚点</p>
<blockquote>
<p>锚点是网页制作中的一种，又叫命名锚记。命名锚记像一个迅速定位器一样是一种页面内的超级链接，运用相当普遍</p>
</blockquote>
<h3 id="注释方法"><a href="#注释方法" class="headerlink" title="注释方法"></a>注释方法</h3><p>这种可以直接跳转到这里，进行解释。暂时规定注释时#为五个但（）中的#只能为一个</p>
<p>参考：</p>
<ul>
<li><a class="link"   href="https://list.yinxiang.com/markdown/eef42447-db3f-48ee-827b-1bb34c03eb83.php" >印象笔记markdown入门指南<i class="fas fa-external-link-alt"></i></a></li>
<li><a class="link"   href="https://dillinger.io/" >一个在线markdown编辑工具，里面有模板<i class="fas fa-external-link-alt"></i></a></li>
</ul>
<h3 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h3><p>右上角<a href="%E7%82%B9%E4%BA%86%E4%BC%9A%E8%B7%B3%E8%BD%AC%E5%88%B0%E8%A7%A3%E9%87%8A">^1</a>有个脚注<a href="%E5%86%8D%E7%82%B9%E4%BC%9A%E5%9B%9E%E5%8E%BB">^2</a></p>
<h1 id="Markdown-的目录树怎么做出来"><a href="#Markdown-的目录树怎么做出来" class="headerlink" title="Markdown 的目录树怎么做出来"></a>Markdown 的目录树怎么做出来</h1><p>win 自带<br>有个shell命令叫 tree<br>see <a class="link"   href="http://linux.die.net/man/1/tree" >http://linux.die.net/man/1/tree<i class="fas fa-external-link-alt"></i></a><br>Mac下要装tree，不然terminal里用不了  中文乱码 tree -N</p>
<h1 id="typora"><a href="#typora" class="headerlink" title="typora"></a>typora</h1><p>页面跳转需要按住ctrl点击</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2021/03/10/LeetCode/</url>
    <content><![CDATA[<h3 id="1-删除排序数组中的重复项"><a href="#1-删除排序数组中的重复项" class="headerlink" title="1 删除排序数组中的重复项"></a>1 删除排序数组中的重复项</h3><p>给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定数组 nums &#x3D; [1,1,2], </span><br><span class="line"></span><br><span class="line">函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 </span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定 nums &#x3D; [0,0,1,1,1,2,2,3,3,4],</span><br><span class="line"></span><br><span class="line">函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。</span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure>
<p>说明:</p>
<p>为什么返回数值是整数，但输出的答案是数组呢?</p>
<p>请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p>
<p>你可以想象内部操作如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝</span><br><span class="line">int len &#x3D; removeDuplicates(nums);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 在函数里修改输入数组对于调用者是可见的。</span><br><span class="line">&#x2F;&#x2F; 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。</span><br><span class="line">for (int i &#x3D; 0; i &lt; len; i++) &#123;</span><br><span class="line">    print(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>个人解法<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">RemoveDuplicates</span>(<span class="params"><span class="built_in">int</span>[] nums</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums.Length==<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">1</span>;i&lt;nums.Length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[count]!=nums[i])&#123;</span><br><span class="line">                </span><br><span class="line">                nums[++count]=nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>最佳<br>解法： 双指针</li>
</ul>
<p>首先注意数组是有序的，那么重复的元素一定会相邻。</p>
<p>要求删除重复元素，实际上就是将不重复的元素移到数组的左侧。</p>
<p>考虑用 2 个指针，一个在前记作 p，一个在后记作 q，算法流程如下：</p>
<p>1.比较 p 和 q 位置的元素是否相等。</p>
<p>如果相等，q 后移 1 位<br>如果不相等，将 q 位置的元素复制到 p+1 位置上，p 后移一位，q 后移 1 位<br>重复上述过程，直到 q 等于数组长度。</p>
<p>返回 p + 1，即为新数组长度。</p>
<p>画个图理解一下</p>
<p><img src="https://pic.leetcode-cn.com/0039d16b169059e8e7f998c618b6c2b269c2d95b02f43415350bde1f661e503a-1.png" alt="image"></p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> q = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(q &lt; nums.length)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[p] != nums[q])&#123;</span><br><span class="line">            nums[p + <span class="number">1</span>] = nums[q];</span><br><span class="line">            p++;</span><br><span class="line">        &#125;</span><br><span class="line">        q++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复杂度分析：</p>
<p>时间复杂度：O(n)O(n)。<br>空间复杂度：O(1)O(1)。</p>
<p>优化：</p>
<p>这是大部分题解都没有提出的，在这里提一下。</p>
<p>考虑如下数组：</p>
<p><img src="https://pic.leetcode-cn.com/06e80bea0bfa0dadc6891407a237fef245f950cab74d050027ac3beecb65d778-2.png" alt="image"></p>
<p>此时数组中没有重复元素，按照上面的方法，每次比较时 nums[p] 都不等于 nums[q]，因此就会将 q 指向的元素原地复制一遍，这个操作其实是不必要的。</p>
<p>因此我们可以添加一个小判断，当 q - p &gt; 1 时，才进行复制。</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> q = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(q &lt; nums.length)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[p] != nums[q])&#123;</span><br><span class="line">            <span class="keyword">if</span>(q - p &gt; <span class="number">1</span>)&#123;</span><br><span class="line">                nums[p + <span class="number">1</span>] = nums[q];</span><br><span class="line">            &#125;</span><br><span class="line">            p++;</span><br><span class="line">        &#125;</span><br><span class="line">        q++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复杂度分析：</p>
<p>时间复杂度：O(n)O(n)。<br>空间复杂度：O(1)O(1)。</p>
<h3 id="2-移除元素"><a href="#2-移除元素" class="headerlink" title="2 移除元素"></a>2 移除元素</h3><p>给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。</p>
<p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p>
<p> </p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定 nums &#x3D; [3,2,2,3], val &#x3D; 3,</span><br><span class="line"></span><br><span class="line">函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。</span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定 nums &#x3D; [0,1,2,2,3,0,4,2], val &#x3D; 2,</span><br><span class="line"></span><br><span class="line">函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。</span><br><span class="line"></span><br><span class="line">注意这五个元素可为任意顺序。</span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure>
<p>说明:</p>
<p>为什么返回数值是整数，但输出的答案是数组呢?</p>
<p>请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p>
<p>你可以想象内部操作如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝</span><br><span class="line">int len &#x3D; removeElement(nums, val);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 在函数里修改输入数组对于调用者是可见的。</span><br><span class="line">&#x2F;&#x2F; 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。</span><br><span class="line">for (int i &#x3D; 0; i &lt; len; i++) &#123;</span><br><span class="line">    print(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>解法1<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">RemoveElement</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=nums.Length;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]!=val)&#123;</span><br><span class="line">                nums[++k]=nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>解法2<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] == val) &#123;</span><br><span class="line">            nums[i] = nums[n - <span class="number">1</span>];</span><br><span class="line">            <span class="comment">// reduce array size by one</span></span><br><span class="line">            n--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-加一"><a href="#6-加一" class="headerlink" title="6 加一"></a>6 加一</h3>给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。</li>
</ul>
<p>最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。</p>
<p>你可以假设除了整数 0 之外，这个整数不会以零开头。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3]</span><br><span class="line">输出: [1,2,4]</span><br><span class="line">解释: 输入数组表示数字 123。</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [4,3,2,1]</span><br><span class="line">输出: [4,3,2,2]</span><br><span class="line">解释: 输入数组表示数字 4321。</span><br></pre></td></tr></table></figure>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="built_in">int</span>[] <span class="title">PlusOne</span>(<span class="params"><span class="built_in">int</span>[] digits</span>)</span></span><br><span class="line"><span class="function"></span>            &#123;</span><br><span class="line">                Stack&lt;<span class="built_in">int</span>&gt; myStack = <span class="keyword">new</span> Stack&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">                <span class="built_in">bool</span> isPlusOne = <span class="literal">false</span>;</span><br><span class="line">                <span class="built_in">int</span> length = digits.Length;</span><br><span class="line">                <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//数组最后一个元素，即遍历的第一个元素，不论何值都需要加1</span></span><br><span class="line">                    <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">                        isPlusOne = <span class="literal">true</span>;</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">if</span> (digits[length - <span class="number">1</span> - i] == <span class="number">9</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">//对数组中为9的元素进行计算</span></span><br><span class="line">                        <span class="built_in">int</span> val = isPlusOne ? <span class="number">0</span> : <span class="number">9</span>;</span><br><span class="line">                        myStack.Push(val);</span><br><span class="line">                        isPlusOne = val == <span class="number">0</span> ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">//对数组中不为9的元素进行计算</span></span><br><span class="line">                        <span class="built_in">int</span> val = isPlusOne ? digits[length - <span class="number">1</span> - i] + <span class="number">1</span> : digits[length - <span class="number">1</span> - i];</span><br><span class="line">                        myStack.Push(val);</span><br><span class="line">                        isPlusOne = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (isPlusOne)</span><br><span class="line">                    myStack.Push(<span class="number">1</span>);</span><br><span class="line">                <span class="comment">//将栈中的元素存入数组</span></span><br><span class="line">                <span class="built_in">int</span>[] outArr = <span class="keyword">new</span> <span class="built_in">int</span>[myStack.Count];</span><br><span class="line">                <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; outArr.Length; i++)</span><br><span class="line">                    outArr[i] = myStack.Pop();</span><br><span class="line">                <span class="keyword">return</span> outArr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-移动0"><a href="#7-移动0" class="headerlink" title="7.移动0"></a>7.移动0</h3><p>给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。</p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [0,1,0,3,12]</span><br><span class="line">输出: [1,3,12,0,0]</span><br></pre></td></tr></table></figure>
<p>说明:</p>
<p>必须在原数组上操作，不能拷贝额外的数组。<br>尽量减少操作次数。</p>
<ul>
<li>解法一 个人解法<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MoveZeroes</span>(<span class="params"><span class="built_in">int</span>[] nums</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">int</span> k=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;nums.Length;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i]==<span class="number">0</span>)&#123;</span><br><span class="line">                    k++;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    nums[i-k]=nums[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(;k&gt;<span class="number">0</span>;k--)&#123;</span><br><span class="line">                nums[nums.Length-k]=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
此解法将非零元素向前移动，记录零的个数最后补上零。</li>
<li>解法二 <figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MoveZeroes</span>(<span class="params"><span class="built_in">int</span>[] nums</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums==<span class="literal">null</span>||nums.Length==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">int</span> k=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;nums.Length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]!=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">int</span> tmp=nums[i];</span><br><span class="line">                nums[i]=nums[k];</span><br><span class="line">                nums[k++]=tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
此解法参考快速排序的思想，快速排序首先要确定一个待分割的元素做中间点x，然后把所有小于等于x的元素放到x的左边，大于x的元素放到其右边。<br>这里我们可以用0当做这个中间点，把不等于0(注意题目没说不能有负数)的放到中间点的左边，等于0的放到其右边。<br>这的中间点就是0本身，所以实现起来比快速排序简单很多，我们使用两个指针i和j，只要nums[i]!=0，我们就交换nums[i]和nums[k]<br><a href="#(%E4%BD%9C%E8%80%85%EF%BC%9Amax-LFszNScOfE,%E9%93%BE%E6%8E%A5%EF%BC%9Ahttps://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/solution/shuang-zhi-zhen-shan-chu-zhong-fu-xiang-dai-you-hu/)">//</a>:#(作者：wang_ni_ma 链接：<a class="link"   href="https://leetcode-cn.com/problems/move-zeroes/solution/dong-hua-yan-shi-283yi-dong-ling-by-wang_ni_ma/" >https://leetcode-cn.com/problems/move-zeroes/solution/dong-hua-yan-shi-283yi-dong-ling-by-wang_ni_ma/<i class="fas fa-external-link-alt"></i></a>)</li>
</ul>
<ul>
<li>解法二的优化<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MoveZeroes</span>(<span class="params"><span class="built_in">int</span>[] nums</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums==<span class="literal">null</span>||nums.Length==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">int</span> k=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;nums.Length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]!=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i&gt;k)&#123;</span><br><span class="line">                <span class="built_in">int</span> tmp=nums[i];</span><br><span class="line">                nums[i]=nums[k];</span><br><span class="line">                nums[k]=tmp;</span><br><span class="line">                &#125;</span><br><span class="line">                k++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
解法二当数组中零的个数较少时 容易出现原地复制浪费资源，做个判断，当i与k指向的同一位置就不互换。</li>
</ul>
<h3 id="8两数之和"><a href="#8两数之和" class="headerlink" title="8两数之和"></a>8两数之和</h3><p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定 nums &#x3D; [2, 7, 11, 15], target &#x3D; 9</span><br><span class="line"></span><br><span class="line">因为 nums[0] + nums[1] &#x3D; 2 + 7 &#x3D; 9</span><br><span class="line">所以返回 [0, 1]</span><br></pre></td></tr></table></figure>
<ul>
<li>解法一 个人解法<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span>[] <span class="title">TwoSum</span>(<span class="params"><span class="built_in">int</span>[] nums, <span class="built_in">int</span> target</span>)</span> &#123;</span><br><span class="line">        List&lt;<span class="built_in">int</span>&gt; list=<span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">        list.AddRange(nums);</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;nums.Length;i++)&#123;</span><br><span class="line">            <span class="built_in">int</span> tmp=target-nums[i];</span><br><span class="line">            <span class="keyword">if</span>(list.LastIndexOf(tmp)!=i&amp;&amp;list.Contains(tmp))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">int</span>[]&#123;i,list.LastIndexOf(tmp)&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
我想到了取差值 但使用的List   实际上使用Hash比较方便</li>
<li>解法一优化<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span>[] <span class="title">TwoSum</span>(<span class="params"><span class="built_in">int</span>[] nums, <span class="built_in">int</span> target</span>)</span> &#123;</span><br><span class="line">       Dictionary&lt;<span class="built_in">int</span>, <span class="built_in">int</span>&gt; dict = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">int</span>, <span class="built_in">int</span>&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;nums.Length;i++)&#123;</span><br><span class="line">            <span class="built_in">int</span> tmp=target-nums[i];</span><br><span class="line">            <span class="keyword">if</span>(dict.ContainsKey(tmp)&amp;&amp;dict[tmp]!=i)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">int</span>[]&#123;i,dict[tmp]&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!dict.ContainsKey(nums[i]))</span><br><span class="line">                dict.Add(nums[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="9数独"><a href="#9数独" class="headerlink" title="9数独"></a>9数独</h3>判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。</li>
</ul>
<p>数字 1-9 在每一行只能出现一次。<br>数字 1-9 在每一列只能出现一次。<br>数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。</p>
<p><img src="https://img2020.cnblogs.com/blog/2130168/202009/2130168-20200902144508610-304190652.png"><br>上图是一个部分填充的有效的数独。</p>
<p>数独部分空格内已填入了数字，空白格用 ‘.’ 表示。</p>
<p>示例 1:</p>
<p>输入:<br>[<br>  [“5”,”3”,”.”,”.”,”7”,”.”,”.”,”.”,”.”],<br>  [“6”,”.”,”.”,”1”,”9”,”5”,”.”,”.”,”.”],<br>  [“.”,”9”,”8”,”.”,”.”,”.”,”.”,”6”,”.”],<br>  [“8”,”.”,”.”,”.”,”6”,”.”,”.”,”.”,”3”],<br>  [“4”,”.”,”.”,”8”,”.”,”3”,”.”,”.”,”1”],<br>  [“7”,”.”,”.”,”.”,”2”,”.”,”.”,”.”,”6”],<br>  [“.”,”6”,”.”,”.”,”.”,”.”,”2”,”8”,”.”],<br>  [“.”,”.”,”.”,”4”,”1”,”9”,”.”,”.”,”5”],<br>  [“.”,”.”,”.”,”.”,”8”,”.”,”.”,”7”,”9”]<br>]<br>输出: true<br>示例 2:</p>
<p>输入:<br>[<br>  [“8”,”3”,”.”,”.”,”7”,”.”,”.”,”.”,”.”],<br>  [“6”,”.”,”.”,”1”,”9”,”5”,”.”,”.”,”.”],<br>  [“.”,”9”,”8”,”.”,”.”,”.”,”.”,”6”,”.”],<br>  [“8”,”.”,”.”,”.”,”6”,”.”,”.”,”.”,”3”],<br>  [“4”,”.”,”.”,”8”,”.”,”3”,”.”,”.”,”1”],<br>  [“7”,”.”,”.”,”.”,”2”,”.”,”.”,”.”,”6”],<br>  [“.”,”6”,”.”,”.”,”.”,”.”,”2”,”8”,”.”],<br>  [“.”,”.”,”.”,”4”,”1”,”9”,”.”,”.”,”5”],<br>  [“.”,”.”,”.”,”.”,”8”,”.”,”.”,”7”,”9”]<br>]<br>输出: false<br>解释: 除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。<br>     但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。<br>说明:</p>
<p>一个有效的数独（部分已被填充）不一定是可解的。<br>只需要根据以上规则，验证已经填入的数字是否有效即可。<br>给定数独序列只包含数字 1-9 和字符 ‘.’ 。<br>给定数独永远是 9x9 形式的。</p>
<p>来源：力扣（LeetCode）<br>链接：<a class="link"   href="https://leetcode-cn.com/problems/valid-sudoku" >https://leetcode-cn.com/problems/valid-sudoku<i class="fas fa-external-link-alt"></i></a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<ul>
<li>解法一<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">IsValidSudoku</span>(<span class="params"><span class="built_in">char</span>[][] board</span>)</span> &#123;</span><br><span class="line">           <span class="built_in">int</span>[,] row=<span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">9</span>,<span class="number">10</span>];</span><br><span class="line">           <span class="built_in">int</span>[,] col=<span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">9</span>,<span class="number">10</span>];</span><br><span class="line">           <span class="built_in">int</span>[,] box=<span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">9</span>,<span class="number">10</span>];</span><br><span class="line">           <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;<span class="number">9</span>;i++)&#123;</span><br><span class="line">               <span class="keyword">for</span>(<span class="built_in">int</span> j=<span class="number">0</span>;j&lt;<span class="number">9</span>;j++)&#123;</span><br><span class="line">                   <span class="keyword">if</span>(board[i][j]==<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">                   <span class="keyword">continue</span>;</span><br><span class="line">                   <span class="built_in">int</span> curNum=board[i][j]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                   <span class="keyword">if</span>(row[i,curNum]==<span class="number">1</span> ||col[j,curNum]==<span class="number">1</span>||box[j/<span class="number">3</span>+(i/<span class="number">3</span>)*<span class="number">3</span>,curNum]==<span class="number">1</span> )</span><br><span class="line">                   <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                   row[i,curNum]=<span class="number">1</span>;</span><br><span class="line">                   col[j,curNum]=<span class="number">1</span>;</span><br><span class="line">                   box[j/<span class="number">3</span>+(i/<span class="number">3</span>)*<span class="number">3</span>,curNum]=<span class="number">1</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>解法二<br>使用递归回溯  正常情况下递归应该是比循环消耗更大，可该方法反而更快，没有找到原因。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidSudoku</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (board == <span class="keyword">null</span> || board.length &gt; <span class="number">9</span> || board[<span class="number">0</span>].length &gt; <span class="number">9</span> ) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> backTrace(board, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">backTrace</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果col越界，那么重新指向下一行</span></span><br><span class="line">        <span class="keyword">if</span> (col == <span class="number">9</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> backTrace(board,row+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果row越界，说明遍历完成，那么当前返回true</span></span><br><span class="line">        <span class="keyword">if</span> (row == <span class="number">9</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果当前位置没有显示数字，直接跳向下一个位置</span></span><br><span class="line">        <span class="keyword">if</span> (board[row][col] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> backTrace(board,row,col+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这个位置数字已给出，需要试探，</span></span><br><span class="line">        <span class="keyword">if</span> (board[row][col] != <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">//如果在当前位置上不成立直接返回false</span></span><br><span class="line">            <span class="keyword">if</span> (!isValid(board, row, col)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果这个位置上成立。直接试探下一个位置</span></span><br><span class="line">            <span class="keyword">return</span> backTrace(board,row,col+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果全部遍历之后，没有false那么就返回true</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> ch = board[row][col];</span><br><span class="line">        <span class="comment">// 三个方向，任一方向，其它8个位置上的数和当前位置ch不能相同</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">9</span>; k++) &#123;</span><br><span class="line">            <span class="comment">// 同一行九个位置已出现 ch</span></span><br><span class="line">            <span class="keyword">if</span> (board[row][k] == ch) &#123;</span><br><span class="line">                <span class="keyword">if</span> (k != col) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 同一列九个位置中已出现 ch</span></span><br><span class="line">            <span class="keyword">if</span> (board[k][col] == ch)&#123;</span><br><span class="line">                <span class="keyword">if</span> (k != row) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//看其他8个位置是否出现ch</span></span><br><span class="line">            <span class="comment">// 同一个子数独九个位置中已出现 ch</span></span><br><span class="line">            <span class="keyword">if</span> (board[(row / <span class="number">3</span>) * <span class="number">3</span> + k / <span class="number">3</span>][(col / <span class="number">3</span>) * <span class="number">3</span> + k % <span class="number">3</span>] == ch)&#123;</span><br><span class="line">                <span class="keyword">if</span> ((row / <span class="number">3</span>) * <span class="number">3</span> + k / <span class="number">3</span> != row &amp;&amp; (col / <span class="number">3</span>) * <span class="number">3</span> + k % <span class="number">3</span> != col) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="旋转图像"><a href="#旋转图像" class="headerlink" title="旋转图像"></a>旋转图像</h3></li>
</ul>
<p>给定一个 n × n 的二维矩阵表示一个图像。</p>
<p>将图像顺时针旋转 90 度。</p>
<p>说明：</p>
<p>你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定 matrix &#x3D; </span><br><span class="line">[</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [4,5,6],</span><br><span class="line">  [7,8,9]</span><br><span class="line">],</span><br><span class="line"></span><br><span class="line">原地旋转输入矩阵，使其变为:</span><br><span class="line">[</span><br><span class="line">  [7,4,1],</span><br><span class="line">  [8,5,2],</span><br><span class="line">  [9,6,3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定 matrix &#x3D;</span><br><span class="line">[</span><br><span class="line">  [ 5, 1, 9,11],</span><br><span class="line">  [ 2, 4, 8,10],</span><br><span class="line">  [13, 3, 6, 7],</span><br><span class="line">  [15,14,12,16]</span><br><span class="line">], </span><br><span class="line"></span><br><span class="line">原地旋转输入矩阵，使其变为:</span><br><span class="line">[</span><br><span class="line">  [15,13, 2, 5],</span><br><span class="line">  [14, 3, 4, 1],</span><br><span class="line">  [12, 6, 8, 9],</span><br><span class="line">  [16, 7,10,11]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<ul>
<li>解法一<br>此解法不太普适，看到旋转后的行正好是旋转前列的倒置，以此规律，将每一列倒置后再变为行<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> rotate = <span class="function"><span class="keyword">function</span>(<span class="params">matrix</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> arr=[];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;matrix.length;i++)&#123;</span><br><span class="line">        <span class="keyword">let</span> newCur=[];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">0</span>;j&lt;matrix.length;j++)&#123;</span><br><span class="line">            newCur.push(matrix[j][i]);</span><br><span class="line">        &#125;</span><br><span class="line">        newCur.reverse();</span><br><span class="line">        arr[i]=newCur;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> a=<span class="number">0</span>;a&lt;matrix.length;a++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> b=<span class="number">0</span>;b&lt;matrix.length;b++)&#123;</span><br><span class="line">            matrix[a][b]=arr[a][b];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>解法二<br>正规解法，按照坐标进行位置变换。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>, y = matrix[<span class="number">0</span>].length - <span class="number">1</span>; x &lt; y; x++, y--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> s = x, e = y; s &lt; y; s++, e--) &#123;</span><br><span class="line">                temp = matrix[x][s];</span><br><span class="line">                matrix[x][s] = matrix[e][x];</span><br><span class="line">                matrix[e][x] = matrix[y][e];</span><br><span class="line">                matrix[y][e] = matrix[s][y];</span><br><span class="line">                matrix[s][y] = temp;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li>
<li>解法三<br>翻折法  先上下翻折在沿副对角线翻折<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;        </span><br><span class="line">        <span class="keyword">int</span> n = matrix.length;        </span><br><span class="line">        <span class="comment">//上下翻转        </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n / <span class="number">2</span>; i ++)&#123;            </span><br><span class="line">            <span class="keyword">int</span>[] tmp = matrix[i];            </span><br><span class="line">            matrix[i] = matrix[n - i - <span class="number">1</span>];            </span><br><span class="line">            matrix[n - i - <span class="number">1</span>] = tmp;       </span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="comment">//对角线翻转        </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++)&#123;            </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j= i + <span class="number">1</span>; j &lt; n; j++)&#123;                </span><br><span class="line">                <span class="keyword">int</span> tmp = matrix[i][j];                </span><br><span class="line">                matrix[i][j] = matrix[j][i];                </span><br><span class="line">                matrix[j][i] = tmp;            </span><br><span class="line">            &#125;       </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="在每一个数字中间加上一个“，”"><a href="#在每一个数字中间加上一个“，”" class="headerlink" title="在每一个数字中间加上一个“，”"></a>在每一个数字中间加上一个“，”</h3></li>
</ul>
<p>知乎上的一个问题，如输入a[6]={1,2,3,4,5,6}输出1，2，3，4，5，6；<br>记录一个大佬的回答</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">6</span>]=&#123;<span class="number">1</span>,<span class="number">23</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;,%d&quot;</span>+!i,a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
</search>
